/**
 * @fileoverview
 * @enhanceable
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.walletrpc.AccountBalance', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse.Account', null, global);
goog.exportSymbol('proto.walletrpc.AgendasRequest', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse.Agenda', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse.Choice', null, global);
goog.exportSymbol('proto.walletrpc.BalanceRequest', null, global);
goog.exportSymbol('proto.walletrpc.BalanceResponse', null, global);
goog.exportSymbol('proto.walletrpc.BestBlockRequest', null, global);
goog.exportSymbol('proto.walletrpc.BestBlockResponse', null, global);
goog.exportSymbol('proto.walletrpc.BlockDetails', null, global);
goog.exportSymbol('proto.walletrpc.BlockInfoRequest', null, global);
goog.exportSymbol('proto.walletrpc.BlockInfoResponse', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest.Key', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseResponse', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.CoinTypeRequest', null, global);
goog.exportSymbol('proto.walletrpc.CoinTypeResponse', null, global);
goog.exportSymbol('proto.walletrpc.CommittedTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.CommittedTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.CommittedTicketsResponse.TicketAddress', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.Output', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputDestination', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureRequest.SigHashType', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateWatchingOnlyWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateWatchingOnlyWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodeRawTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.DecodeRawTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Input', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Input.TreeType', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Output', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Output.ScriptClass', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesRequest', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesResponse', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersNotification', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersRequest', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersResponse', null, global);
goog.exportSymbol('proto.walletrpc.FetchMissingCFiltersNotification', null, global);
goog.exportSymbol('proto.walletrpc.FetchMissingCFiltersRequest', null, global);
goog.exportSymbol('proto.walletrpc.FetchMissingCFiltersResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse.PreviousOutput', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetAccountExtendedPrivKeyRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetAccountExtendedPrivKeyResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetAccountExtendedPubKeyRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetAccountExtendedPubKeyResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse.BlockDetails', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse.TicketDetails', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptResponse', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersRequest', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersResponse', null, global);
goog.exportSymbol('proto.walletrpc.NetworkRequest', null, global);
goog.exportSymbol('proto.walletrpc.NetworkResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest.GapPolicy', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest.Kind', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.PeerNotification', null, global);
goog.exportSymbol('proto.walletrpc.PingRequest', null, global);
goog.exportSymbol('proto.walletrpc.PingResponse', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.PublishUnminedTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.PublishUnminedTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.RescanPointRequest', null, global);
goog.exportSymbol('proto.walletrpc.RescanPointResponse', null, global);
goog.exportSymbol('proto.walletrpc.RescanProgressNotification', null, global);
goog.exportSymbol('proto.walletrpc.RescanRequest', null, global);
goog.exportSymbol('proto.walletrpc.RescanResponse', null, global);
goog.exportSymbol('proto.walletrpc.RevokeTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.RevokeTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.RpcSyncRequest', null, global);
goog.exportSymbol('proto.walletrpc.RpcSyncResponse', null, global);
goog.exportSymbol('proto.walletrpc.RunTicketBuyerRequest', null, global);
goog.exportSymbol('proto.walletrpc.RunTicketBuyerResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetBalanceToMaintainRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetBalanceToMaintainResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxFeeRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxFeeResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPerBlockRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPerBlockResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceAbsoluteRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceAbsoluteResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceRelativeRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceRelativeResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolFeesRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolFeesResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesRequest.Choice', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetVotingAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetVotingAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignMessageRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignMessageResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignMessagesRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignMessagesRequest.Message', null, global);
goog.exportSymbol('proto.walletrpc.SignMessagesResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignMessagesResponse.SignReply', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionRequest.AdditionalScript', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionsRequest.AdditionalScript', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionsRequest.UnsignedTransaction', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionsResponse.SignedTransaction', null, global);
goog.exportSymbol('proto.walletrpc.SpvSyncRequest', null, global);
goog.exportSymbol('proto.walletrpc.SpvSyncResponse', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoRequest', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoResponse', null, global);
goog.exportSymbol('proto.walletrpc.StartAutoBuyerRequest', null, global);
goog.exportSymbol('proto.walletrpc.StartAutoBuyerResponse', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcRequest', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcResponse', null, global);
goog.exportSymbol('proto.walletrpc.StopAutoBuyerRequest', null, global);
goog.exportSymbol('proto.walletrpc.StopAutoBuyerResponse', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.SweepAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.SweepAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.SyncNotificationType', null, global);
goog.exportSymbol('proto.walletrpc.TicketBuyerConfigRequest', null, global);
goog.exportSymbol('proto.walletrpc.TicketBuyerConfigResponse', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceRequest', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceResponse', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Input', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Output', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.TransactionType', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.UnspentOutputResponse', null, global);
goog.exportSymbol('proto.walletrpc.UnspentOutputsRequest', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressResponse.ScriptType', null, global);
goog.exportSymbol('proto.walletrpc.VerifyMessageRequest', null, global);
goog.exportSymbol('proto.walletrpc.VerifyMessageResponse', null, global);
goog.exportSymbol('proto.walletrpc.VersionRequest', null, global);
goog.exportSymbol('proto.walletrpc.VersionResponse', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesRequest', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesResponse', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesResponse.Choice', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsRequest', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionRequest.displayName = 'proto.walletrpc.VersionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VersionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionRequest;
  return proto.walletrpc.VersionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VersionRequest} The clone.
 */
proto.walletrpc.VersionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VersionRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionResponse.displayName = 'proto.walletrpc.VersionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VersionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    versionString: msg.getVersionString(),
    major: msg.getMajor(),
    minor: msg.getMinor(),
    patch: msg.getPatch(),
    prerelease: msg.getPrerelease(),
    buildMetadata: msg.getBuildMetadata()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionResponse;
  return proto.walletrpc.VersionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersionString(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMajor(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinor(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPatch(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrerelease(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setBuildMetadata(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVersionString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getMajor();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getMinor();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getPatch();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getPrerelease();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getBuildMetadata();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VersionResponse} The clone.
 */
proto.walletrpc.VersionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VersionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string version_string = 1;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getVersionString = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.VersionResponse.prototype.setVersionString = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 major = 2;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMajor = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.VersionResponse.prototype.setMajor = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 minor = 3;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMinor = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.VersionResponse.prototype.setMinor = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 patch = 4;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getPatch = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.VersionResponse.prototype.setPatch = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string prerelease = 5;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getPrerelease = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/** @param {string} value  */
proto.walletrpc.VersionResponse.prototype.setPrerelease = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string build_metadata = 6;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getBuildMetadata = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 6, ""));
};


/** @param {string} value  */
proto.walletrpc.VersionResponse.prototype.setBuildMetadata = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.displayName = 'proto.walletrpc.TransactionDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionDetails.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    transaction: msg.getTransaction_asB64(),
    debitsList: jspb.Message.toObjectList(msg.getDebitsList(),
    proto.walletrpc.TransactionDetails.Input.toObject, includeInstance),
    creditsList: jspb.Message.toObjectList(msg.getCreditsList(),
    proto.walletrpc.TransactionDetails.Output.toObject, includeInstance),
    fee: msg.getFee(),
    timestamp: msg.getTimestamp(),
    transactionType: msg.getTransactionType()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails;
  return proto.walletrpc.TransactionDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails.Input;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader);
      msg.getDebitsList().push(value);
      msg.setDebitsList(msg.getDebitsList());
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails.Output;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader);
      msg.getCreditsList().push(value);
      msg.setCreditsList(msg.getCreditsList());
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFee(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 7:
      var value = /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (reader.readEnum());
      msg.setTransactionType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getDebitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter
    );
  }
  f = this.getCreditsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter
    );
  }
  f = this.getFee();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = this.getTransactionType();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TransactionDetails} The clone.
 */
proto.walletrpc.TransactionDetails.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TransactionDetails} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.TransactionDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes transaction = 2;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.TransactionDetails.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated Input debits = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Input>}
 */
proto.walletrpc.TransactionDetails.prototype.getDebitsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Input>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Input, 3));
};


/** @param {Array.<!proto.walletrpc.TransactionDetails.Input>} value  */
proto.walletrpc.TransactionDetails.prototype.setDebitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


proto.walletrpc.TransactionDetails.prototype.clearDebitsList = function() {
  this.setDebitsList([]);
};


/**
 * repeated Output credits = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Output>}
 */
proto.walletrpc.TransactionDetails.prototype.getCreditsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Output, 4));
};


/** @param {Array.<!proto.walletrpc.TransactionDetails.Output>} value  */
proto.walletrpc.TransactionDetails.prototype.setCreditsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


proto.walletrpc.TransactionDetails.prototype.clearCreditsList = function() {
  this.setCreditsList([]);
};


/**
 * optional int64 fee = 5;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.prototype.setFee = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 timestamp = 6;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional TransactionType transaction_type = 7;
 * @return {!proto.walletrpc.TransactionDetails.TransactionType}
 */
proto.walletrpc.TransactionDetails.prototype.getTransactionType = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {!proto.walletrpc.TransactionDetails.TransactionType} value  */
proto.walletrpc.TransactionDetails.prototype.setTransactionType = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.TransactionDetails.TransactionType = {
  REGULAR: 0,
  COINBASE: 4,
  TICKET_PURCHASE: 1,
  VOTE: 2,
  REVOCATION: 3
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Input.displayName = 'proto.walletrpc.TransactionDetails.Input';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: msg.getIndex(),
    previousAccount: msg.getPreviousAccount(),
    previousAmount: msg.getPreviousAmount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Input;
  return proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPreviousAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPreviousAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Input} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Input.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getPreviousAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getPreviousAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TransactionDetails.Input} The clone.
 */
proto.walletrpc.TransactionDetails.Input.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.Input} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Input.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 previous_account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 previous_amount = 3;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Output.displayName = 'proto.walletrpc.TransactionDetails.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: msg.getIndex(),
    account: msg.getAccount(),
    internal: msg.getInternal(),
    amount: msg.getAmount(),
    address: msg.getAddress(),
    outputScript: msg.getOutputScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Output;
  return proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInternal(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOutputScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Output} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Output.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getInternal();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getOutputScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TransactionDetails.Output} The clone.
 */
proto.walletrpc.TransactionDetails.Output.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.Output} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool internal = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getInternal = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 3, false));
};


/** @param {boolean} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setInternal = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 amount = 4;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string address = 5;
 * @return {string}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/** @param {string} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bytes output_script = 6;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 6, ""));
};


/**
 * optional bytes output_script = 6;
 * This is a type-conversion wrapper around `getOutputScript()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOutputScript()));
};


/**
 * optional bytes output_script = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOutputScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOutputScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.TransactionDetails.Output.prototype.setOutputScript = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.BlockDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.BlockDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockDetails.displayName = 'proto.walletrpc.BlockDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.BlockDetails.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BlockDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    height: msg.getHeight(),
    timestamp: msg.getTimestamp(),
    approvesParent: msg.getApprovesParent(),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockDetails;
  return proto.walletrpc.BlockDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setApprovesParent(value);
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.getTransactionsList().push(value);
      msg.setTransactionsList(msg.getTransactionsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getApprovesParent();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = this.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BlockDetails} The clone.
 */
proto.walletrpc.BlockDetails.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BlockDetails} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.BlockDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockDetails.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 timestamp = 3;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool approves_parent = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.BlockDetails.prototype.getApprovesParent = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 5, false));
};


/** @param {boolean} value  */
proto.walletrpc.BlockDetails.prototype.setApprovesParent = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * repeated TransactionDetails transactions = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.BlockDetails.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 4));
};


/** @param {Array.<!proto.walletrpc.TransactionDetails>} value  */
proto.walletrpc.BlockDetails.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


proto.walletrpc.BlockDetails.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountBalance = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountBalance, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountBalance.displayName = 'proto.walletrpc.AccountBalance';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountBalance.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountBalance.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountBalance} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountBalance.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount(),
    totalBalance: msg.getTotalBalance()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountBalance;
  return proto.walletrpc.AccountBalance.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountBalance} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountBalance} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountBalance.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountBalance.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountBalance.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountBalance} The clone.
 */
proto.walletrpc.AccountBalance.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountBalance} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountBalance.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_balance = 2;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountBalance.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingRequest.displayName = 'proto.walletrpc.PingRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PingRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingRequest;
  return proto.walletrpc.PingRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PingRequest} The clone.
 */
proto.walletrpc.PingRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PingRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingResponse.displayName = 'proto.walletrpc.PingResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PingResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingResponse;
  return proto.walletrpc.PingResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PingResponse} The clone.
 */
proto.walletrpc.PingResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PingResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkRequest.displayName = 'proto.walletrpc.NetworkRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NetworkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkRequest;
  return proto.walletrpc.NetworkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NetworkRequest} The clone.
 */
proto.walletrpc.NetworkRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NetworkRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkResponse.displayName = 'proto.walletrpc.NetworkResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NetworkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    activeNetwork: msg.getActiveNetwork()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkResponse;
  return proto.walletrpc.NetworkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setActiveNetwork(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getActiveNetwork();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NetworkResponse} The clone.
 */
proto.walletrpc.NetworkResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NetworkResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 active_network = 1;
 * @return {number}
 */
proto.walletrpc.NetworkResponse.prototype.getActiveNetwork = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.NetworkResponse.prototype.setActiveNetwork = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CoinTypeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CoinTypeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CoinTypeRequest.displayName = 'proto.walletrpc.CoinTypeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CoinTypeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CoinTypeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CoinTypeRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CoinTypeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CoinTypeRequest}
 */
proto.walletrpc.CoinTypeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CoinTypeRequest;
  return proto.walletrpc.CoinTypeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CoinTypeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CoinTypeRequest}
 */
proto.walletrpc.CoinTypeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CoinTypeRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CoinTypeRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CoinTypeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CoinTypeRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CoinTypeRequest} The clone.
 */
proto.walletrpc.CoinTypeRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CoinTypeRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CoinTypeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CoinTypeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CoinTypeResponse.displayName = 'proto.walletrpc.CoinTypeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CoinTypeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CoinTypeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CoinTypeResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CoinTypeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    coinType: msg.getCoinType()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CoinTypeResponse}
 */
proto.walletrpc.CoinTypeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CoinTypeResponse;
  return proto.walletrpc.CoinTypeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CoinTypeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CoinTypeResponse}
 */
proto.walletrpc.CoinTypeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCoinType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CoinTypeResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CoinTypeResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CoinTypeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CoinTypeResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getCoinType();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CoinTypeResponse} The clone.
 */
proto.walletrpc.CoinTypeResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CoinTypeResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 coin_type = 1;
 * @return {number}
 */
proto.walletrpc.CoinTypeResponse.prototype.getCoinType = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.CoinTypeResponse.prototype.setCoinType = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberRequest.displayName = 'proto.walletrpc.AccountNumberRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNumberRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountName: msg.getAccountName()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberRequest;
  return proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountNumberRequest} The clone.
 */
proto.walletrpc.AccountNumberRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountNumberRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string account_name = 1;
 * @return {string}
 */
proto.walletrpc.AccountNumberRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.AccountNumberRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberResponse.displayName = 'proto.walletrpc.AccountNumberResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNumberResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberResponse;
  return proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountNumberResponse} The clone.
 */
proto.walletrpc.AccountNumberResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountNumberResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNumberResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountNumberResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsRequest.displayName = 'proto.walletrpc.AccountsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsRequest;
  return proto.walletrpc.AccountsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountsRequest} The clone.
 */
proto.walletrpc.AccountsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AccountsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AccountsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.displayName = 'proto.walletrpc.AccountsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AccountsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountsList: jspb.Message.toObjectList(msg.getAccountsList(),
    proto.walletrpc.AccountsResponse.Account.toObject, includeInstance),
    currentBlockHash: msg.getCurrentBlockHash_asB64(),
    currentBlockHeight: msg.getCurrentBlockHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse;
  return proto.walletrpc.AccountsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.AccountsResponse.Account;
      reader.readMessage(value,proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader);
      msg.getAccountsList().push(value);
      msg.setAccountsList(msg.getAccountsList());
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurrentBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCurrentBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter
    );
  }
  f = this.getCurrentBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getCurrentBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountsResponse} The clone.
 */
proto.walletrpc.AccountsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated Account accounts = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.AccountsResponse.Account>}
 */
proto.walletrpc.AccountsResponse.prototype.getAccountsList = function() {
  return /** @type{!Array.<!proto.walletrpc.AccountsResponse.Account>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AccountsResponse.Account, 1));
};


/** @param {Array.<!proto.walletrpc.AccountsResponse.Account>} value  */
proto.walletrpc.AccountsResponse.prototype.setAccountsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.AccountsResponse.prototype.clearAccountsList = function() {
  this.setAccountsList([]);
};


/**
 * optional bytes current_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes current_block_hash = 2;
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {string}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurrentBlockHash()));
};


/**
 * optional bytes current_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurrentBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 current_block_height = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse.Account = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsResponse.Account, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.Account.displayName = 'proto.walletrpc.AccountsResponse.Account';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.Account.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.Account.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.Account.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber(),
    accountName: msg.getAccountName(),
    totalBalance: msg.getTotalBalance(),
    externalKeyCount: msg.getExternalKeyCount(),
    internalKeyCount: msg.getInternalKeyCount(),
    importedKeyCount: msg.getImportedKeyCount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse.Account;
  return proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse.Account} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.Account.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.Account.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = this.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountsResponse.Account} The clone.
 */
proto.walletrpc.AccountsResponse.Account.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountsResponse.Account} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_balance = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 external_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 internal_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 imported_key_count = 6;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountsResponse.Account.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountRequest.displayName = 'proto.walletrpc.RenameAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RenameAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber(),
    newName: msg.getNewName()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountRequest;
  return proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getNewName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RenameAccountRequest} The clone.
 */
proto.walletrpc.RenameAccountRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RenameAccountRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.RenameAccountRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.RenameAccountRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string new_name = 2;
 * @return {string}
 */
proto.walletrpc.RenameAccountRequest.prototype.getNewName = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.RenameAccountRequest.prototype.setNewName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountResponse.displayName = 'proto.walletrpc.RenameAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RenameAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountResponse;
  return proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RenameAccountResponse} The clone.
 */
proto.walletrpc.RenameAccountResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RenameAccountResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanRequest.displayName = 'proto.walletrpc.RescanRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    beginHeight: msg.getBeginHeight(),
    beginHash: msg.getBeginHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanRequest;
  return proto.walletrpc.RescanRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBeginHeight(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBeginHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getBeginHeight();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = this.getBeginHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RescanRequest} The clone.
 */
proto.walletrpc.RescanRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RescanRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 begin_height = 1;
 * @return {number}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.RescanRequest.prototype.setBeginHeight = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes begin_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes begin_hash = 2;
 * This is a type-conversion wrapper around `getBeginHash()`
 * @return {string}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBeginHash()));
};


/**
 * optional bytes begin_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBeginHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBeginHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RescanRequest.prototype.setBeginHash = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanResponse.displayName = 'proto.walletrpc.RescanResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    rescannedThrough: msg.getRescannedThrough()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanResponse;
  return proto.walletrpc.RescanResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRescannedThrough(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getRescannedThrough();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RescanResponse} The clone.
 */
proto.walletrpc.RescanResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RescanResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 rescanned_through = 1;
 * @return {number}
 */
proto.walletrpc.RescanResponse.prototype.getRescannedThrough = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.RescanResponse.prototype.setRescannedThrough = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountRequest.displayName = 'proto.walletrpc.NextAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    accountName: msg.getAccountName()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountRequest;
  return proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NextAccountRequest} The clone.
 */
proto.walletrpc.NextAccountRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NextAccountRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.NextAccountRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.NextAccountRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountResponse.displayName = 'proto.walletrpc.NextAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountResponse;
  return proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NextAccountResponse} The clone.
 */
proto.walletrpc.NextAccountResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NextAccountResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.NextAccountResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.NextAccountResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressRequest.displayName = 'proto.walletrpc.NextAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount(),
    kind: msg.getKind(),
    gapPolicy: msg.getGapPolicy()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressRequest;
  return proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (reader.readEnum());
      msg.setKind(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.NextAddressRequest.GapPolicy} */ (reader.readEnum());
      msg.setGapPolicy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getKind();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = this.getGapPolicy();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NextAddressRequest} The clone.
 */
proto.walletrpc.NextAddressRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.NextAddressRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.NextAddressRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional Kind kind = 2;
 * @return {!proto.walletrpc.NextAddressRequest.Kind}
 */
proto.walletrpc.NextAddressRequest.prototype.getKind = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {!proto.walletrpc.NextAddressRequest.Kind} value  */
proto.walletrpc.NextAddressRequest.prototype.setKind = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional GapPolicy gap_policy = 3;
 * @return {!proto.walletrpc.NextAddressRequest.GapPolicy}
 */
proto.walletrpc.NextAddressRequest.prototype.getGapPolicy = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest.GapPolicy} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {!proto.walletrpc.NextAddressRequest.GapPolicy} value  */
proto.walletrpc.NextAddressRequest.prototype.setGapPolicy = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.NextAddressRequest.Kind = {
  BIP0044_EXTERNAL: 0,
  BIP0044_INTERNAL: 1
};

/**
 * @enum {number}
 */
proto.walletrpc.NextAddressRequest.GapPolicy = {
  GAP_POLICY_UNSPECIFIED: 0,
  GAP_POLICY_ERROR: 1,
  GAP_POLICY_IGNORE: 2,
  GAP_POLICY_WRAP: 3
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressResponse.displayName = 'proto.walletrpc.NextAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress(),
    publicKey: msg.getPublicKey()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressResponse;
  return proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getPublicKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.NextAddressResponse} The clone.
 */
proto.walletrpc.NextAddressResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.NextAddressResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.NextAddressResponse.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string public_key = 2;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.NextAddressResponse.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyRequest.displayName = 'proto.walletrpc.ImportPrivateKeyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: msg.getAccount(),
    privateKeyWif: msg.getPrivateKeyWif(),
    rescan: msg.getRescan(),
    scanFrom: msg.getScanFrom()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyRequest;
  return proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrivateKeyWif(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getPrivateKeyWif();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = this.getRescan();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = this.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest} The clone.
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ImportPrivateKeyRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string private_key_wif = 3;
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPrivateKeyWif = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/** @param {string} value  */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPrivateKeyWif = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool rescan = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 4, false));
};


/** @param {boolean} value  */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 scan_from = 5;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyResponse.displayName = 'proto.walletrpc.ImportPrivateKeyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyResponse;
  return proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse} The clone.
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ImportPrivateKeyResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptRequest.displayName = 'proto.walletrpc.ImportScriptRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportScriptRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    script: msg.getScript_asB64(),
    rescan: msg.getRescan(),
    scanFrom: msg.getScanFrom(),
    requireRedeemable: msg.getRequireRedeemable()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptRequest;
  return proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRequireRedeemable(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getRescan();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = this.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = this.getRequireRedeemable();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ImportScriptRequest} The clone.
 */
proto.walletrpc.ImportScriptRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ImportScriptRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ImportScriptRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ImportScriptRequest.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool rescan = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 3, false));
};


/** @param {boolean} value  */
proto.walletrpc.ImportScriptRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 scan_from = 4;
 * @return {number}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.ImportScriptRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool require_redeemable = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptRequest.prototype.getRequireRedeemable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 5, false));
};


/** @param {boolean} value  */
proto.walletrpc.ImportScriptRequest.prototype.setRequireRedeemable = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptResponse.displayName = 'proto.walletrpc.ImportScriptResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportScriptResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    p2shAddress: msg.getP2shAddress(),
    redeemable: msg.getRedeemable()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptResponse;
  return proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setP2shAddress(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRedeemable(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getP2shAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getRedeemable();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ImportScriptResponse} The clone.
 */
proto.walletrpc.ImportScriptResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ImportScriptResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string p2sh_address = 1;
 * @return {string}
 */
proto.walletrpc.ImportScriptResponse.prototype.getP2shAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.ImportScriptResponse.prototype.setP2shAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool redeemable = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptResponse.prototype.getRedeemable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 2, false));
};


/** @param {boolean} value  */
proto.walletrpc.ImportScriptResponse.prototype.setRedeemable = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceRequest.displayName = 'proto.walletrpc.BalanceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BalanceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber(),
    requiredConfirmations: msg.getRequiredConfirmations()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceRequest;
  return proto.walletrpc.BalanceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BalanceRequest} The clone.
 */
proto.walletrpc.BalanceRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BalanceRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceResponse.displayName = 'proto.walletrpc.BalanceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BalanceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    total: msg.getTotal(),
    spendable: msg.getSpendable(),
    immatureReward: msg.getImmatureReward(),
    immatureStakeGeneration: msg.getImmatureStakeGeneration(),
    lockedByTickets: msg.getLockedByTickets(),
    votingAuthority: msg.getVotingAuthority(),
    unconfirmed: msg.getUnconfirmed()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceResponse;
  return proto.walletrpc.BalanceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotal(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendable(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setImmatureReward(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setImmatureStakeGeneration(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLockedByTickets(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setVotingAuthority(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUnconfirmed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTotal();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = this.getSpendable();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getImmatureReward();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getImmatureStakeGeneration();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getLockedByTickets();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getVotingAuthority();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = this.getUnconfirmed();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BalanceResponse} The clone.
 */
proto.walletrpc.BalanceResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BalanceResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 total = 1;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getTotal = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setTotal = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 spendable = 2;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getSpendable = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setSpendable = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 immature_reward = 3;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getImmatureReward = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setImmatureReward = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 immature_stake_generation = 4;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getImmatureStakeGeneration = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setImmatureStakeGeneration = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 locked_by_tickets = 5;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getLockedByTickets = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setLockedByTickets = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 voting_authority = 6;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getVotingAuthority = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setVotingAuthority = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 unconfirmed = 7;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getUnconfirmed = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.BalanceResponse.prototype.setUnconfirmed = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionRequest.displayName = 'proto.walletrpc.GetTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionRequest}
 */
proto.walletrpc.GetTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionRequest;
  return proto.walletrpc.GetTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionRequest}
 */
proto.walletrpc.GetTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTransactionRequest} The clone.
 */
proto.walletrpc.GetTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTransactionRequest.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionResponse.displayName = 'proto.walletrpc.GetTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: (f = msg.getTransaction()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f),
    confirmations: msg.getConfirmations(),
    blockHash: msg.getBlockHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionResponse}
 */
proto.walletrpc.GetTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionResponse;
  return proto.walletrpc.GetTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionResponse}
 */
proto.walletrpc.GetTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setTransaction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setConfirmations(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransaction();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = this.getConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTransactionResponse} The clone.
 */
proto.walletrpc.GetTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional TransactionDetails transaction = 1;
 * @return {proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTransactionResponse.prototype.getTransaction = function() {
  return /** @type{proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 1));
};


/** @param {proto.walletrpc.TransactionDetails|undefined} value  */
proto.walletrpc.GetTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTransactionResponse.prototype.clearTransaction = function() {
  this.setTransaction(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTransactionResponse.prototype.hasTransaction = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int32 confirmations = 2;
 * @return {number}
 */
proto.walletrpc.GetTransactionResponse.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTransactionResponse.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionResponse.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes block_hash = 3;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionResponse.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionResponse.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTransactionResponse.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsRequest.displayName = 'proto.walletrpc.GetTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startingBlockHash: msg.getStartingBlockHash_asB64(),
    startingBlockHeight: msg.getStartingBlockHeight(),
    endingBlockHash: msg.getEndingBlockHash_asB64(),
    endingBlockHeight: msg.getEndingBlockHeight(),
    minimumRecentTransactions: msg.getMinimumRecentTransactions(),
    targetTransactionCount: msg.getTargetTransactionCount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsRequest;
  return proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setStartingBlockHeight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEndingBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEndingBlockHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinimumRecentTransactions(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetTransactionCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getStartingBlockHeight();
  if (f !== 0) {
    writer.writeSint32(
      2,
      f
    );
  }
  f = this.getEndingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getEndingBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = this.getMinimumRecentTransactions();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = this.getTargetTransactionCount();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTransactionsRequest} The clone.
 */
proto.walletrpc.GetTransactionsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTransactionsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes starting_block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes starting_block_hash = 1;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional sint32 starting_block_height = 2;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes ending_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes ending_block_hash = 3;
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEndingBlockHash()));
};


/**
 * optional bytes ending_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEndingBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 ending_block_height = 4;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 minimum_recent_transactions = 5;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getMinimumRecentTransactions = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setMinimumRecentTransactions = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int32 target_transaction_count = 6;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getTargetTransactionCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTransactionsRequest.prototype.setTargetTransactionCount = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.GetTransactionsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.GetTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsResponse.displayName = 'proto.walletrpc.GetTransactionsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.GetTransactionsResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    minedTransactions: (f = msg.getMinedTransactions()) && proto.walletrpc.BlockDetails.toObject(includeInstance, f),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsResponse;
  return proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.setMinedTransactions(value);
      break;
    case 2:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.getUnminedTransactionsList().push(value);
      msg.setUnminedTransactionsList(msg.getUnminedTransactionsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMinedTransactions();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = this.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTransactionsResponse} The clone.
 */
proto.walletrpc.GetTransactionsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTransactionsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional BlockDetails mined_transactions = 1;
 * @return {proto.walletrpc.BlockDetails}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getMinedTransactions = function() {
  return /** @type{proto.walletrpc.BlockDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {proto.walletrpc.BlockDetails|undefined} value  */
proto.walletrpc.GetTransactionsResponse.prototype.setMinedTransactions = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearMinedTransactions = function() {
  this.setMinedTransactions(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTransactionsResponse.prototype.hasMinedTransactions = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated TransactionDetails unmined_transactions = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 2));
};


/** @param {Array.<!proto.walletrpc.TransactionDetails>} value  */
proto.walletrpc.GetTransactionsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketRequest.displayName = 'proto.walletrpc.GetTicketRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTicketRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketHash: msg.getTicketHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketRequest}
 */
proto.walletrpc.GetTicketRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketRequest;
  return proto.walletrpc.GetTicketRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketRequest}
 */
proto.walletrpc.GetTicketRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTicketHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTicketRequest} The clone.
 */
proto.walletrpc.GetTicketRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTicketRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes ticket_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketRequest.prototype.getTicketHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes ticket_hash = 1;
 * This is a type-conversion wrapper around `getTicketHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketRequest.prototype.getTicketHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTicketHash()));
};


/**
 * optional bytes ticket_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicketHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketRequest.prototype.getTicketHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTicketHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTicketRequest.prototype.setTicketHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsRequest.displayName = 'proto.walletrpc.GetTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startingBlockHash: msg.getStartingBlockHash_asB64(),
    startingBlockHeight: msg.getStartingBlockHeight(),
    endingBlockHash: msg.getEndingBlockHash_asB64(),
    endingBlockHeight: msg.getEndingBlockHeight(),
    targetTicketCount: msg.getTargetTicketCount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsRequest}
 */
proto.walletrpc.GetTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsRequest;
  return proto.walletrpc.GetTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsRequest}
 */
proto.walletrpc.GetTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setStartingBlockHeight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEndingBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEndingBlockHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetTicketCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getStartingBlockHeight();
  if (f !== 0) {
    writer.writeSint32(
      2,
      f
    );
  }
  f = this.getEndingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getEndingBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = this.getTargetTicketCount();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTicketsRequest} The clone.
 */
proto.walletrpc.GetTicketsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTicketsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes starting_block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes starting_block_hash = 1;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTicketsRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional sint32 starting_block_height = 2;
 * @return {number}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTicketsRequest.prototype.setStartingBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes ending_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes ending_block_hash = 3;
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEndingBlockHash()));
};


/**
 * optional bytes ending_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEndingBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTicketsRequest.prototype.setEndingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 ending_block_height = 4;
 * @return {number}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTicketsRequest.prototype.setEndingBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 target_ticket_count = 5;
 * @return {number}
 */
proto.walletrpc.GetTicketsRequest.prototype.getTargetTicketCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTicketsRequest.prototype.setTargetTicketCount = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsResponse.displayName = 'proto.walletrpc.GetTicketsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticket: (f = msg.getTicket()) && proto.walletrpc.GetTicketsResponse.TicketDetails.toObject(includeInstance, f),
    block: (f = msg.getBlock()) && proto.walletrpc.GetTicketsResponse.BlockDetails.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsResponse}
 */
proto.walletrpc.GetTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsResponse;
  return proto.walletrpc.GetTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsResponse}
 */
proto.walletrpc.GetTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.GetTicketsResponse.TicketDetails;
      reader.readMessage(value,proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader);
      msg.setTicket(value);
      break;
    case 2:
      var value = new proto.walletrpc.GetTicketsResponse.BlockDetails;
      reader.readMessage(value,proto.walletrpc.GetTicketsResponse.BlockDetails.deserializeBinaryFromReader);
      msg.setBlock(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.GetTicketsResponse.TicketDetails.serializeBinaryToWriter
    );
  }
  f = this.getBlock();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.walletrpc.GetTicketsResponse.BlockDetails.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTicketsResponse} The clone.
 */
proto.walletrpc.GetTicketsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTicketsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional TicketDetails ticket = 1;
 * @return {proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.prototype.getTicket = function() {
  return /** @type{proto.walletrpc.GetTicketsResponse.TicketDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.GetTicketsResponse.TicketDetails, 1));
};


/** @param {proto.walletrpc.GetTicketsResponse.TicketDetails|undefined} value  */
proto.walletrpc.GetTicketsResponse.prototype.setTicket = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTicketsResponse.prototype.clearTicket = function() {
  this.setTicket(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTicketsResponse.prototype.hasTicket = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional BlockDetails block = 2;
 * @return {proto.walletrpc.GetTicketsResponse.BlockDetails}
 */
proto.walletrpc.GetTicketsResponse.prototype.getBlock = function() {
  return /** @type{proto.walletrpc.GetTicketsResponse.BlockDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.GetTicketsResponse.BlockDetails, 2));
};


/** @param {proto.walletrpc.GetTicketsResponse.BlockDetails|undefined} value  */
proto.walletrpc.GetTicketsResponse.prototype.setBlock = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.walletrpc.GetTicketsResponse.prototype.clearBlock = function() {
  this.setBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTicketsResponse.prototype.hasBlock = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsResponse.TicketDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsResponse.TicketDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsResponse.TicketDetails.displayName = 'proto.walletrpc.GetTicketsResponse.TicketDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsResponse.TicketDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticket: (f = msg.getTicket()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f),
    spender: (f = msg.getSpender()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f),
    ticketStatus: msg.getTicketStatus()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsResponse.TicketDetails;
  return proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setTicket(value);
      break;
    case 2:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setSpender(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} */ (reader.readEnum());
      msg.setTicketStatus(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = this.getSpender();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = this.getTicketStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails} The clone.
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTicketsResponse.TicketDetails} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional TransactionDetails ticket = 1;
 * @return {proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getTicket = function() {
  return /** @type{proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 1));
};


/** @param {proto.walletrpc.TransactionDetails|undefined} value  */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setTicket = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.clearTicket = function() {
  this.setTicket(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.hasTicket = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TransactionDetails spender = 2;
 * @return {proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getSpender = function() {
  return /** @type{proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 2));
};


/** @param {proto.walletrpc.TransactionDetails|undefined} value  */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setSpender = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.clearSpender = function() {
  this.setSpender(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.hasSpender = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TicketStatus ticket_status = 3;
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getTicketStatus = function() {
  return /** @type {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} value  */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setTicketStatus = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus = {
  UNKNOWN: 0,
  UNMINED: 1,
  IMMATURE: 2,
  LIVE: 3,
  VOTED: 4,
  MISSED: 5,
  EXPIRED: 6,
  REVOKED: 7
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsResponse.BlockDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsResponse.BlockDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsResponse.BlockDetails.displayName = 'proto.walletrpc.GetTicketsResponse.BlockDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsResponse.BlockDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsResponse.BlockDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    height: msg.getHeight(),
    timestamp: msg.getTimestamp()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsResponse.BlockDetails}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsResponse.BlockDetails;
  return proto.walletrpc.GetTicketsResponse.BlockDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsResponse.BlockDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsResponse.BlockDetails}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsResponse.BlockDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetTicketsResponse.BlockDetails} The clone.
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetTicketsResponse.BlockDetails} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 timestamp = 3;
 * @return {number}
 */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.GetTicketsResponse.BlockDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceRequest.displayName = 'proto.walletrpc.TicketPriceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketPriceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceRequest;
  return proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TicketPriceRequest} The clone.
 */
proto.walletrpc.TicketPriceRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TicketPriceRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceResponse.displayName = 'proto.walletrpc.TicketPriceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketPriceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketPrice: msg.getTicketPrice(),
    height: msg.getHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceResponse;
  return proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketPrice(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketPrice();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = this.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TicketPriceResponse} The clone.
 */
proto.walletrpc.TicketPriceResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TicketPriceResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 ticket_price = 1;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getTicketPrice = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketPriceResponse.prototype.setTicketPrice = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketPriceResponse.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoRequest.displayName = 'proto.walletrpc.StakeInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StakeInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoRequest;
  return proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StakeInfoRequest} The clone.
 */
proto.walletrpc.StakeInfoRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StakeInfoRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoResponse.displayName = 'proto.walletrpc.StakeInfoResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StakeInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolSize: msg.getPoolSize(),
    allMempoolTix: msg.getAllMempoolTix(),
    ownMempoolTix: msg.getOwnMempoolTix(),
    immature: msg.getImmature(),
    live: msg.getLive(),
    voted: msg.getVoted(),
    missed: msg.getMissed(),
    revoked: msg.getRevoked(),
    expired: msg.getExpired(),
    totalSubsidy: msg.getTotalSubsidy(),
    unspent: msg.getUnspent()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoResponse;
  return proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPoolSize(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAllMempoolTix(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOwnMempoolTix(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImmature(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLive(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVoted(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMissed(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRevoked(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpired(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalSubsidy(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setUnspent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPoolSize();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAllMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getOwnMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getImmature();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getLive();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = this.getVoted();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = this.getMissed();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = this.getRevoked();
  if (f !== 0) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = this.getExpired();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = this.getTotalSubsidy();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = this.getUnspent();
  if (f !== 0) {
    writer.writeUint32(
      11,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StakeInfoResponse} The clone.
 */
proto.walletrpc.StakeInfoResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StakeInfoResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 pool_size = 1;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getPoolSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setPoolSize = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 all_mempool_tix = 2;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getAllMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setAllMempoolTix = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 own_mempool_tix = 3;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getOwnMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setOwnMempoolTix = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 immature = 4;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getImmature = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setImmature = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 live = 5;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getLive = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setLive = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 voted = 6;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getVoted = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setVoted = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 missed = 7;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getMissed = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setMissed = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional uint32 revoked = 8;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getRevoked = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 8, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setRevoked = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expired = 9;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getExpired = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 9, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setExpired = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 total_subsidy = 10;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getTotalSubsidy = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 10, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setTotalSubsidy = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional uint32 unspent = 11;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getUnspent = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 11, 0));
};


/** @param {number} value  */
proto.walletrpc.StakeInfoResponse.prototype.setUnspent = function(value) {
  jspb.Message.setField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BlockInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockInfoRequest.displayName = 'proto.walletrpc.BlockInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BlockInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: msg.getBlockHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockInfoRequest}
 */
proto.walletrpc.BlockInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockInfoRequest;
  return proto.walletrpc.BlockInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockInfoRequest}
 */
proto.walletrpc.BlockInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockInfoRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockInfoRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BlockInfoRequest} The clone.
 */
proto.walletrpc.BlockInfoRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BlockInfoRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes block_hash = 1;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.BlockInfoRequest.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 block_height = 2;
 * @return {number}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockInfoRequest.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BlockInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockInfoResponse.displayName = 'proto.walletrpc.BlockInfoResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BlockInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: msg.getBlockHeight(),
    confirmations: msg.getConfirmations(),
    timestamp: msg.getTimestamp(),
    blockHeader: msg.getBlockHeader_asB64(),
    stakeInvalidated: msg.getStakeInvalidated(),
    approvesParent: msg.getApprovesParent()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockInfoResponse}
 */
proto.walletrpc.BlockInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockInfoResponse;
  return proto.walletrpc.BlockInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockInfoResponse}
 */
proto.walletrpc.BlockInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setConfirmations(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHeader(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setStakeInvalidated(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setApprovesParent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockInfoResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockInfoResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getBlockHeader_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = this.getStakeInvalidated();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getApprovesParent();
  if (f) {
    writer.writeBool(
      7,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BlockInfoResponse} The clone.
 */
proto.walletrpc.BlockInfoResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BlockInfoResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes block_hash = 1;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 block_height = 2;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 confirmations = 3;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockInfoResponse.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 timestamp = 4;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.BlockInfoResponse.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes block_header = 5;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/**
 * optional bytes block_header = 5;
 * This is a type-conversion wrapper around `getBlockHeader()`
 * @return {string}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHeader()));
};


/**
 * optional bytes block_header = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHeader()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHeader()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHeader = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool stake_invalidated = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.BlockInfoResponse.prototype.getStakeInvalidated = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 6, false));
};


/** @param {boolean} value  */
proto.walletrpc.BlockInfoResponse.prototype.setStakeInvalidated = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional bool approves_parent = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.BlockInfoResponse.prototype.getApprovesParent = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 7, false));
};


/** @param {boolean} value  */
proto.walletrpc.BlockInfoResponse.prototype.setApprovesParent = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseRequest.displayName = 'proto.walletrpc.ChangePassphraseRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: msg.getKey(),
    oldPassphrase: msg.getOldPassphrase_asB64(),
    newPassphrase: msg.getNewPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseRequest;
  return proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (reader.readEnum());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOldPassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getKey();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = this.getOldPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getNewPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ChangePassphraseRequest} The clone.
 */
proto.walletrpc.ChangePassphraseRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ChangePassphraseRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional Key key = 1;
 * @return {!proto.walletrpc.ChangePassphraseRequest.Key}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getKey = function() {
  return /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {!proto.walletrpc.ChangePassphraseRequest.Key} value  */
proto.walletrpc.ChangePassphraseRequest.prototype.setKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes old_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes old_passphrase = 2;
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOldPassphrase()));
};


/**
 * optional bytes old_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOldPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ChangePassphraseRequest.prototype.setOldPassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes new_passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes new_passphrase = 3;
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewPassphrase()));
};


/**
 * optional bytes new_passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ChangePassphraseRequest.prototype.setNewPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.ChangePassphraseRequest.Key = {
  PRIVATE: 0,
  PUBLIC: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseResponse.displayName = 'proto.walletrpc.ChangePassphraseResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseResponse;
  return proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ChangePassphraseResponse} The clone.
 */
proto.walletrpc.ChangePassphraseResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ChangePassphraseResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionRequest.displayName = 'proto.walletrpc.FundTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount(),
    targetAmount: msg.getTargetAmount(),
    requiredConfirmations: msg.getRequiredConfirmations(),
    includeImmatureCoinbases: msg.getIncludeImmatureCoinbases(),
    includeChangeScript: msg.getIncludeChangeScript()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionRequest;
  return proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTargetAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeImmatureCoinbases(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeChangeScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getTargetAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getIncludeImmatureCoinbases();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = this.getIncludeChangeScript();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FundTransactionRequest} The clone.
 */
proto.walletrpc.FundTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FundTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 target_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getTargetAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionRequest.prototype.setTargetAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 required_confirmations = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool include_immature_coinbases = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeImmatureCoinbases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 4, false));
};


/** @param {boolean} value  */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeImmatureCoinbases = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool include_change_script = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeChangeScript = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 5, false));
};


/** @param {boolean} value  */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeChangeScript = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.FundTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.displayName = 'proto.walletrpc.FundTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.FundTransactionResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectedOutputsList: jspb.Message.toObjectList(msg.getSelectedOutputsList(),
    proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject, includeInstance),
    totalAmount: msg.getTotalAmount(),
    changePkScript: msg.getChangePkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse;
  return proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
      reader.readMessage(value,proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader);
      msg.getSelectedOutputsList().push(value);
      msg.setSelectedOutputsList(msg.getSelectedOutputsList());
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmount(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChangePkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSelectedOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter
    );
  }
  f = this.getTotalAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getChangePkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FundTransactionResponse} The clone.
 */
proto.walletrpc.FundTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FundTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated PreviousOutput selected_outputs = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>}
 */
proto.walletrpc.FundTransactionResponse.prototype.getSelectedOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.FundTransactionResponse.PreviousOutput, 1));
};


/** @param {Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} value  */
proto.walletrpc.FundTransactionResponse.prototype.setSelectedOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.FundTransactionResponse.prototype.clearSelectedOutputsList = function() {
  this.setSelectedOutputsList([]);
};


/**
 * optional int64 total_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.prototype.getTotalAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionResponse.prototype.setTotalAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes change_pk_script = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes change_pk_script = 3;
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChangePkScript()));
};


/**
 * optional bytes change_pk_script = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChangePkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.FundTransactionResponse.prototype.setChangePkScript = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse.PreviousOutput, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.PreviousOutput.displayName = 'proto.walletrpc.FundTransactionResponse.PreviousOutput';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: msg.getOutputIndex(),
    amount: msg.getAmount(),
    pkScript: msg.getPkScript_asB64(),
    receiveTime: msg.getReceiveTime(),
    fromCoinbase: msg.getFromCoinbase(),
    tree: msg.getTree()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setReceiveTime(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFromCoinbase(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getReceiveTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getFromCoinbase();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getTree();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput} The clone.
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FundTransactionResponse.PreviousOutput} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amount = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 receive_time = 5;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getReceiveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setReceiveTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool from_coinbase = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getFromCoinbase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 6, false));
};


/** @param {boolean} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setFromCoinbase = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 tree = 7;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTree = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.UnspentOutputsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.UnspentOutputsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.UnspentOutputsRequest.displayName = 'proto.walletrpc.UnspentOutputsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.UnspentOutputsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.UnspentOutputsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.UnspentOutputsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount(),
    targetAmount: msg.getTargetAmount(),
    requiredConfirmations: msg.getRequiredConfirmations(),
    includeImmatureCoinbases: msg.getIncludeImmatureCoinbases()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.UnspentOutputsRequest}
 */
proto.walletrpc.UnspentOutputsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.UnspentOutputsRequest;
  return proto.walletrpc.UnspentOutputsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.UnspentOutputsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.UnspentOutputsRequest}
 */
proto.walletrpc.UnspentOutputsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTargetAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeImmatureCoinbases(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.UnspentOutputsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.UnspentOutputsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.UnspentOutputsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getTargetAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getIncludeImmatureCoinbases();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.UnspentOutputsRequest} The clone.
 */
proto.walletrpc.UnspentOutputsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.UnspentOutputsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputsRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 target_amount = 2;
 * @return {number}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.getTargetAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputsRequest.prototype.setTargetAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 required_confirmations = 3;
 * @return {number}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputsRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool include_immature_coinbases = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.UnspentOutputsRequest.prototype.getIncludeImmatureCoinbases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 4, false));
};


/** @param {boolean} value  */
proto.walletrpc.UnspentOutputsRequest.prototype.setIncludeImmatureCoinbases = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.UnspentOutputResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.UnspentOutputResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.UnspentOutputResponse.displayName = 'proto.walletrpc.UnspentOutputResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.UnspentOutputResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.UnspentOutputResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.UnspentOutputResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.UnspentOutputResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: msg.getOutputIndex(),
    amount: msg.getAmount(),
    pkScript: msg.getPkScript_asB64(),
    receiveTime: msg.getReceiveTime(),
    fromCoinbase: msg.getFromCoinbase(),
    tree: msg.getTree(),
    amountSum: msg.getAmountSum()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.UnspentOutputResponse}
 */
proto.walletrpc.UnspentOutputResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.UnspentOutputResponse;
  return proto.walletrpc.UnspentOutputResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.UnspentOutputResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.UnspentOutputResponse}
 */
proto.walletrpc.UnspentOutputResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setReceiveTime(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFromCoinbase(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmountSum(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.UnspentOutputResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.UnspentOutputResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.UnspentOutputResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.UnspentOutputResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getReceiveTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getFromCoinbase();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getTree();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = this.getAmountSum();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.UnspentOutputResponse} The clone.
 */
proto.walletrpc.UnspentOutputResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.UnspentOutputResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amount = 3;
 * @return {number}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 receive_time = 5;
 * @return {number}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getReceiveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setReceiveTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool from_coinbase = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getFromCoinbase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 6, false));
};


/** @param {boolean} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setFromCoinbase = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 tree = 7;
 * @return {number}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setTree = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 amount_sum = 8;
 * @return {number}
 */
proto.walletrpc.UnspentOutputResponse.prototype.getAmountSum = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 8, 0));
};


/** @param {number} value  */
proto.walletrpc.UnspentOutputResponse.prototype.setAmountSum = function(value) {
  jspb.Message.setField(this, 8, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConstructTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.displayName = 'proto.walletrpc.ConstructTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConstructTransactionRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    sourceAccount: msg.getSourceAccount(),
    requiredConfirmations: msg.getRequiredConfirmations(),
    feePerKb: msg.getFeePerKb(),
    outputSelectionAlgorithm: msg.getOutputSelectionAlgorithm(),
    nonChangeOutputsList: jspb.Message.toObjectList(msg.getNonChangeOutputsList(),
    proto.walletrpc.ConstructTransactionRequest.Output.toObject, includeInstance),
    changeDestination: (f = msg.getChangeDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest;
  return proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSourceAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFeePerKb(value);
      break;
    case 4:
      var value = /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (reader.readEnum());
      msg.setOutputSelectionAlgorithm(value);
      break;
    case 5:
      var value = new proto.walletrpc.ConstructTransactionRequest.Output;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader);
      msg.getNonChangeOutputsList().push(value);
      msg.setNonChangeOutputsList(msg.getNonChangeOutputsList());
      break;
    case 6:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setChangeDestination(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSourceAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getFeePerKb();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getOutputSelectionAlgorithm();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = this.getNonChangeOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter
    );
  }
  f = this.getChangeDestination();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConstructTransactionRequest} The clone.
 */
proto.walletrpc.ConstructTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 source_account = 1;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getSourceAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setSourceAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 fee_per_kb = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional OutputSelectionAlgorithm output_selection_algorithm = 4;
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getOutputSelectionAlgorithm = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setOutputSelectionAlgorithm = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * repeated Output non_change_outputs = 5;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getNonChangeOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.ConstructTransactionRequest.Output, 5));
};


/** @param {Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setNonChangeOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearNonChangeOutputsList = function() {
  this.setNonChangeOutputsList([]);
};


/**
 * optional OutputDestination change_destination = 6;
 * @return {proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getChangeDestination = function() {
  return /** @type{proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 6));
};


/** @param {proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value  */
proto.walletrpc.ConstructTransactionRequest.prototype.setChangeDestination = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearChangeDestination = function() {
  this.setChangeDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.hasChangeDestination = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * @enum {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm = {
  UNSPECIFIED: 0,
  ALL: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.OutputDestination, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.OutputDestination.displayName = 'proto.walletrpc.ConstructTransactionRequest.OutputDestination';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress(),
    script: msg.getScript_asB64(),
    scriptVersion: msg.getScriptVersion()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getScriptVersion();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} The clone.
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 script_version = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScriptVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.Output.displayName = 'proto.walletrpc.ConstructTransactionRequest.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    destination: (f = msg.getDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f),
    amount: msg.getAmount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.Output;
  return proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setDestination(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDestination();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output} The clone.
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest.Output} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional OutputDestination destination = 1;
 * @return {proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getDestination = function() {
  return /** @type{proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 1));
};


/** @param {proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value  */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setDestination = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.ConstructTransactionRequest.Output.prototype.clearDestination = function() {
  this.setDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.hasDestination = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionResponse.displayName = 'proto.walletrpc.ConstructTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    unsignedTransaction: msg.getUnsignedTransaction_asB64(),
    totalPreviousOutputAmount: msg.getTotalPreviousOutputAmount(),
    totalOutputAmount: msg.getTotalOutputAmount(),
    estimatedSignedSize: msg.getEstimatedSignedSize(),
    changeIndex: msg.getChangeIndex()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionResponse;
  return proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUnsignedTransaction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalPreviousOutputAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalOutputAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEstimatedSignedSize(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setChangeIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getUnsignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTotalPreviousOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getTotalOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getEstimatedSignedSize();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getChangeIndex();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConstructTransactionResponse} The clone.
 */
proto.walletrpc.ConstructTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes unsigned_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes unsigned_transaction = 1;
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUnsignedTransaction()));
};


/**
 * optional bytes unsigned_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUnsignedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ConstructTransactionResponse.prototype.setUnsignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_previous_output_amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalPreviousOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalPreviousOutputAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_output_amount = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalOutputAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 estimated_signed_size = 4;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getEstimatedSignedSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionResponse.prototype.setEstimatedSignedSize = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 change_index = 5;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getChangeIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.ConstructTransactionResponse.prototype.setChangeIndex = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionRequest.displayName = 'proto.walletrpc.SignTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionRequest.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    serializedTransaction: msg.getSerializedTransaction_asB64(),
    additionalScriptsList: jspb.Message.toObjectList(msg.getAdditionalScriptsList(),
    proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionRequest;
  return proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    case 4:
      var value = new proto.walletrpc.SignTransactionRequest.AdditionalScript;
      reader.readMessage(value,proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader);
      msg.getAdditionalScriptsList().push(value);
      msg.setAdditionalScriptsList(msg.getAdditionalScriptsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getAdditionalScriptsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.SignTransactionRequest.AdditionalScript.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionRequest} The clone.
 */
proto.walletrpc.SignTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes serialized_transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes serialized_transaction = 2;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated AdditionalScript additional_scripts = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>}
 */
proto.walletrpc.SignTransactionRequest.prototype.getAdditionalScriptsList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignTransactionRequest.AdditionalScript, 4));
};


/** @param {Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>} value  */
proto.walletrpc.SignTransactionRequest.prototype.setAdditionalScriptsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


proto.walletrpc.SignTransactionRequest.prototype.clearAdditionalScriptsList = function() {
  this.setAdditionalScriptsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignTransactionRequest.AdditionalScript, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionRequest.AdditionalScript.displayName = 'proto.walletrpc.SignTransactionRequest.AdditionalScript';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: msg.getOutputIndex(),
    tree: msg.getTree(),
    pkScript: msg.getPkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionRequest.AdditionalScript;
  return proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getTree();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript} The clone.
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionRequest.AdditionalScript} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 tree = 3;
 * @return {number}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setTree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionResponse.displayName = 'proto.walletrpc.SignTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: msg.getTransaction_asB64(),
    unsignedInputIndexesList: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionResponse;
  return proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 2:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setUnsignedInputIndexesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getUnsignedInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionResponse} The clone.
 */
proto.walletrpc.SignTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction = 1;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated uint32 unsigned_input_indexes = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionResponse.prototype.getUnsignedInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getField(this, 2));
};


/** @param {Array.<number>} value  */
proto.walletrpc.SignTransactionResponse.prototype.setUnsignedInputIndexesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


proto.walletrpc.SignTransactionResponse.prototype.clearUnsignedInputIndexesList = function() {
  jspb.Message.setField(this, 2, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionsRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionsRequest.displayName = 'proto.walletrpc.SignTransactionsRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionsRequest.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.toObject, includeInstance),
    additionalScriptsList: jspb.Message.toObjectList(msg.getAdditionalScriptsList(),
    proto.walletrpc.SignTransactionsRequest.AdditionalScript.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionsRequest}
 */
proto.walletrpc.SignTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionsRequest;
  return proto.walletrpc.SignTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionsRequest}
 */
proto.walletrpc.SignTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = new proto.walletrpc.SignTransactionsRequest.UnsignedTransaction;
      reader.readMessage(value,proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.deserializeBinaryFromReader);
      msg.getTransactionsList().push(value);
      msg.setTransactionsList(msg.getTransactionsList());
      break;
    case 3:
      var value = new proto.walletrpc.SignTransactionsRequest.AdditionalScript;
      reader.readMessage(value,proto.walletrpc.SignTransactionsRequest.AdditionalScript.deserializeBinaryFromReader);
      msg.getAdditionalScriptsList().push(value);
      msg.setAdditionalScriptsList(msg.getAdditionalScriptsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.serializeBinaryToWriter
    );
  }
  f = this.getAdditionalScriptsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.SignTransactionsRequest.AdditionalScript.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionsRequest} The clone.
 */
proto.walletrpc.SignTransactionsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignTransactionsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated UnsignedTransaction transactions = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction>}
 */
proto.walletrpc.SignTransactionsRequest.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignTransactionsRequest.UnsignedTransaction, 2));
};


/** @param {Array.<!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction>} value  */
proto.walletrpc.SignTransactionsRequest.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


proto.walletrpc.SignTransactionsRequest.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};


/**
 * repeated AdditionalScript additional_scripts = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignTransactionsRequest.AdditionalScript>}
 */
proto.walletrpc.SignTransactionsRequest.prototype.getAdditionalScriptsList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignTransactionsRequest.AdditionalScript>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignTransactionsRequest.AdditionalScript, 3));
};


/** @param {Array.<!proto.walletrpc.SignTransactionsRequest.AdditionalScript>} value  */
proto.walletrpc.SignTransactionsRequest.prototype.setAdditionalScriptsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


proto.walletrpc.SignTransactionsRequest.prototype.clearAdditionalScriptsList = function() {
  this.setAdditionalScriptsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignTransactionsRequest.AdditionalScript, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionsRequest.AdditionalScript.displayName = 'proto.walletrpc.SignTransactionsRequest.AdditionalScript';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionsRequest.AdditionalScript.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionsRequest.AdditionalScript} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: msg.getOutputIndex(),
    tree: msg.getTree(),
    pkScript: msg.getPkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionsRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionsRequest.AdditionalScript;
  return proto.walletrpc.SignTransactionsRequest.AdditionalScript.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionsRequest.AdditionalScript} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionsRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionsRequest.AdditionalScript} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getTree();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionsRequest.AdditionalScript} The clone.
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionsRequest.AdditionalScript} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 tree = 3;
 * @return {number}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.setTree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionsRequest.AdditionalScript.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignTransactionsRequest.UnsignedTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.displayName = 'proto.walletrpc.SignTransactionsRequest.UnsignedTransaction';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    serializedTransaction: msg.getSerializedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionsRequest.UnsignedTransaction;
  return proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction} The clone.
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionsRequest.UnsignedTransaction} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes serialized_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes serialized_transaction = 1;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionsRequest.UnsignedTransaction.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionsResponse.displayName = 'proto.walletrpc.SignTransactionsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.walletrpc.SignTransactionsResponse.SignedTransaction.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionsResponse}
 */
proto.walletrpc.SignTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionsResponse;
  return proto.walletrpc.SignTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionsResponse}
 */
proto.walletrpc.SignTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.SignTransactionsResponse.SignedTransaction;
      reader.readMessage(value,proto.walletrpc.SignTransactionsResponse.SignedTransaction.deserializeBinaryFromReader);
      msg.getTransactionsList().push(value);
      msg.setTransactionsList(msg.getTransactionsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.SignTransactionsResponse.SignedTransaction.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionsResponse} The clone.
 */
proto.walletrpc.SignTransactionsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated SignedTransaction transactions = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignTransactionsResponse.SignedTransaction>}
 */
proto.walletrpc.SignTransactionsResponse.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignTransactionsResponse.SignedTransaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignTransactionsResponse.SignedTransaction, 1));
};


/** @param {Array.<!proto.walletrpc.SignTransactionsResponse.SignedTransaction>} value  */
proto.walletrpc.SignTransactionsResponse.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.SignTransactionsResponse.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionsResponse.SignedTransaction.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionsResponse.SignedTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionsResponse.SignedTransaction.displayName = 'proto.walletrpc.SignTransactionsResponse.SignedTransaction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionsResponse.SignedTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionsResponse.SignedTransaction} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: msg.getTransaction_asB64(),
    unsignedInputIndexesList: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionsResponse.SignedTransaction}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionsResponse.SignedTransaction;
  return proto.walletrpc.SignTransactionsResponse.SignedTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionsResponse.SignedTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionsResponse.SignedTransaction}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 2:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setUnsignedInputIndexesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionsResponse.SignedTransaction} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getUnsignedInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignTransactionsResponse.SignedTransaction} The clone.
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignTransactionsResponse.SignedTransaction} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction = 1;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated uint32 unsigned_input_indexes = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.getUnsignedInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getField(this, 2));
};


/** @param {Array.<number>} value  */
proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.setUnsignedInputIndexesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


proto.walletrpc.SignTransactionsResponse.SignedTransaction.prototype.clearUnsignedInputIndexesList = function() {
  jspb.Message.setField(this, 2, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateSignatureRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateSignatureRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateSignatureRequest.displayName = 'proto.walletrpc.CreateSignatureRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateSignatureRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateSignatureRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    address: msg.getAddress(),
    serializedTransaction: msg.getSerializedTransaction_asB64(),
    inputIndex: msg.getInputIndex(),
    hashType: msg.getHashType(),
    previousPkScript: msg.getPreviousPkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateSignatureRequest}
 */
proto.walletrpc.CreateSignatureRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateSignatureRequest;
  return proto.walletrpc.CreateSignatureRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateSignatureRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateSignatureRequest}
 */
proto.walletrpc.CreateSignatureRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputIndex(value);
      break;
    case 5:
      var value = /** @type {!proto.walletrpc.CreateSignatureRequest.SigHashType} */ (reader.readEnum());
      msg.setHashType(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreviousPkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateSignatureRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateSignatureRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateSignatureRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getInputIndex();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getHashType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = this.getPreviousPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateSignatureRequest} The clone.
 */
proto.walletrpc.CreateSignatureRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateSignatureRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes serialized_transaction = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes serialized_transaction = 3;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 input_index = 4;
 * @return {number}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getInputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setInputIndex = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional SigHashType hash_type = 5;
 * @return {!proto.walletrpc.CreateSignatureRequest.SigHashType}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getHashType = function() {
  return /** @type {!proto.walletrpc.CreateSignatureRequest.SigHashType} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {!proto.walletrpc.CreateSignatureRequest.SigHashType} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setHashType = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bytes previous_pk_script = 6;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 6, ""));
};


/**
 * optional bytes previous_pk_script = 6;
 * This is a type-conversion wrapper around `getPreviousPkScript()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreviousPkScript()));
};


/**
 * optional bytes previous_pk_script = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreviousPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreviousPkScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateSignatureRequest.prototype.setPreviousPkScript = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.CreateSignatureRequest.SigHashType = {
  SIGHASH_OLD: 0,
  SIGHASH_ALL: 1,
  SIGHASH_NONE: 2,
  SIGHASH_SINGLE: 3,
  SIGHASH_ALLVALUE: 4,
  SIGHASH_ANYONECANPAY: 128
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateSignatureResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateSignatureResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateSignatureResponse.displayName = 'proto.walletrpc.CreateSignatureResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateSignatureResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateSignatureResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64(),
    publicKey: msg.getPublicKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateSignatureResponse}
 */
proto.walletrpc.CreateSignatureResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateSignatureResponse;
  return proto.walletrpc.CreateSignatureResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateSignatureResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateSignatureResponse}
 */
proto.walletrpc.CreateSignatureResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateSignatureResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateSignatureResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateSignatureResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getPublicKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateSignatureResponse} The clone.
 */
proto.walletrpc.CreateSignatureResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateSignatureResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateSignatureResponse.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes public_key = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes public_key = 2;
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicKey()));
};


/**
 * optional bytes public_key = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicKey()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateSignatureResponse.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionRequest.displayName = 'proto.walletrpc.PublishTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    signedTransaction: msg.getSignedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionRequest;
  return proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PublishTransactionRequest} The clone.
 */
proto.walletrpc.PublishTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PublishTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes signed_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes signed_transaction = 1;
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignedTransaction()));
};


/**
 * optional bytes signed_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.PublishTransactionRequest.prototype.setSignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionResponse.displayName = 'proto.walletrpc.PublishTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionResponse;
  return proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PublishTransactionResponse} The clone.
 */
proto.walletrpc.PublishTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PublishTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.PublishTransactionResponse.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishUnminedTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishUnminedTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishUnminedTransactionsRequest.displayName = 'proto.walletrpc.PublishUnminedTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishUnminedTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishUnminedTransactionsRequest}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishUnminedTransactionsRequest;
  return proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishUnminedTransactionsRequest}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishUnminedTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PublishUnminedTransactionsRequest} The clone.
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PublishUnminedTransactionsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishUnminedTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishUnminedTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishUnminedTransactionsResponse.displayName = 'proto.walletrpc.PublishUnminedTransactionsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishUnminedTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishUnminedTransactionsResponse}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishUnminedTransactionsResponse;
  return proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishUnminedTransactionsResponse}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishUnminedTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PublishUnminedTransactionsResponse} The clone.
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PublishUnminedTransactionsResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsRequest.displayName = 'proto.walletrpc.PurchaseTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: msg.getAccount(),
    spendLimit: msg.getSpendLimit(),
    requiredConfirmations: msg.getRequiredConfirmations(),
    ticketAddress: msg.getTicketAddress(),
    numTickets: msg.getNumTickets(),
    poolAddress: msg.getPoolAddress(),
    poolFees: msg.getPoolFees(),
    expiry: msg.getExpiry(),
    txFee: msg.getTxFee(),
    ticketFee: msg.getTicketFee()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsRequest;
  return proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendLimit(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequiredConfirmations(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setTicketAddress(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumTickets(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTxFee(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketFee(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getSpendLimit();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getTicketAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getNumTickets();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      8,
      f
    );
  }
  f = this.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = this.getTxFee();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = this.getTicketFee();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PurchaseTicketsRequest} The clone.
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PurchaseTicketsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 spend_limit = 3;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getSpendLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setSpendLimit = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 required_confirmations = 4;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string ticket_address = 5;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/** @param {string} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 num_tickets = 6;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getNumTickets = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setNumTickets = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string pool_address = 7;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 7, ""));
};


/** @param {string} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional double pool_fees = 8;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 8, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expiry = 9;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 9, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 tx_fee = 10;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 10, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTxFee = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 ticket_fee = 11;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 11, 0));
};


/** @param {number} value  */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketFee = function(value) {
  jspb.Message.setField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.PurchaseTicketsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsResponse.displayName = 'proto.walletrpc.PurchaseTicketsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.PurchaseTicketsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketHashesList: msg.getTicketHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsResponse;
  return proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.getTicketHashesList().push(value);
      msg.setTicketHashesList(msg.getTicketHashesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PurchaseTicketsResponse} The clone.
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PurchaseTicketsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 1));
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTicketHashesList()));
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTicketHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value  */
proto.walletrpc.PurchaseTicketsResponse.prototype.setTicketHashesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


proto.walletrpc.PurchaseTicketsResponse.prototype.clearTicketHashesList = function() {
  jspb.Message.setField(this, 1, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RevokeTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RevokeTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RevokeTicketsRequest.displayName = 'proto.walletrpc.RevokeTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RevokeTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RevokeTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RevokeTicketsRequest}
 */
proto.walletrpc.RevokeTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RevokeTicketsRequest;
  return proto.walletrpc.RevokeTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RevokeTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RevokeTicketsRequest}
 */
proto.walletrpc.RevokeTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RevokeTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RevokeTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RevokeTicketsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RevokeTicketsRequest} The clone.
 */
proto.walletrpc.RevokeTicketsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RevokeTicketsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RevokeTicketsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RevokeTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RevokeTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RevokeTicketsResponse.displayName = 'proto.walletrpc.RevokeTicketsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RevokeTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RevokeTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RevokeTicketsResponse}
 */
proto.walletrpc.RevokeTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RevokeTicketsResponse;
  return proto.walletrpc.RevokeTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RevokeTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RevokeTicketsResponse}
 */
proto.walletrpc.RevokeTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RevokeTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RevokeTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RevokeTicketsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RevokeTicketsResponse} The clone.
 */
proto.walletrpc.RevokeTicketsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RevokeTicketsResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersRequest.displayName = 'proto.walletrpc.LoadActiveDataFiltersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersRequest;
  return proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest} The clone.
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.LoadActiveDataFiltersRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersResponse.displayName = 'proto.walletrpc.LoadActiveDataFiltersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersResponse;
  return proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse} The clone.
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.LoadActiveDataFiltersResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessageRequest.displayName = 'proto.walletrpc.SignMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress(),
    message: msg.getMessage(),
    passphrase: msg.getPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessageRequest}
 */
proto.walletrpc.SignMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessageRequest;
  return proto.walletrpc.SignMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessageRequest}
 */
proto.walletrpc.SignMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessageRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessageRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessageRequest} The clone.
 */
proto.walletrpc.SignMessageRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessageRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SignMessageRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.SignMessageRequest.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes passphrase = 3;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignMessageRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessageResponse.displayName = 'proto.walletrpc.SignMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessageResponse}
 */
proto.walletrpc.SignMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessageResponse;
  return proto.walletrpc.SignMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessageResponse}
 */
proto.walletrpc.SignMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessageResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessageResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessageResponse} The clone.
 */
proto.walletrpc.SignMessageResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessageResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignMessageResponse.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessagesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignMessagesRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignMessagesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessagesRequest.displayName = 'proto.walletrpc.SignMessagesRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignMessagesRequest.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessagesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessagesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessagesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessagesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    messagesList: jspb.Message.toObjectList(msg.getMessagesList(),
    proto.walletrpc.SignMessagesRequest.Message.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessagesRequest}
 */
proto.walletrpc.SignMessagesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessagesRequest;
  return proto.walletrpc.SignMessagesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessagesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessagesRequest}
 */
proto.walletrpc.SignMessagesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = new proto.walletrpc.SignMessagesRequest.Message;
      reader.readMessage(value,proto.walletrpc.SignMessagesRequest.Message.deserializeBinaryFromReader);
      msg.getMessagesList().push(value);
      msg.setMessagesList(msg.getMessagesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessagesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getMessagesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.SignMessagesRequest.Message.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessagesRequest} The clone.
 */
proto.walletrpc.SignMessagesRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessagesRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessagesRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignMessagesRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignMessagesRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated Message messages = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignMessagesRequest.Message>}
 */
proto.walletrpc.SignMessagesRequest.prototype.getMessagesList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignMessagesRequest.Message>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignMessagesRequest.Message, 2));
};


/** @param {Array.<!proto.walletrpc.SignMessagesRequest.Message>} value  */
proto.walletrpc.SignMessagesRequest.prototype.setMessagesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


proto.walletrpc.SignMessagesRequest.prototype.clearMessagesList = function() {
  this.setMessagesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessagesRequest.Message = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessagesRequest.Message, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessagesRequest.Message.displayName = 'proto.walletrpc.SignMessagesRequest.Message';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessagesRequest.Message.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessagesRequest.Message} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessagesRequest.Message.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress(),
    message: msg.getMessage()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessagesRequest.Message}
 */
proto.walletrpc.SignMessagesRequest.Message.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessagesRequest.Message;
  return proto.walletrpc.SignMessagesRequest.Message.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessagesRequest.Message} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessagesRequest.Message}
 */
proto.walletrpc.SignMessagesRequest.Message.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessagesRequest.Message} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesRequest.Message.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessagesRequest.Message} The clone.
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessagesRequest.Message} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SignMessagesRequest.Message.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.walletrpc.SignMessagesRequest.Message.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.SignMessagesRequest.Message.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessagesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignMessagesResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignMessagesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessagesResponse.displayName = 'proto.walletrpc.SignMessagesResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignMessagesResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessagesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessagesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessagesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessagesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    repliesList: jspb.Message.toObjectList(msg.getRepliesList(),
    proto.walletrpc.SignMessagesResponse.SignReply.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessagesResponse}
 */
proto.walletrpc.SignMessagesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessagesResponse;
  return proto.walletrpc.SignMessagesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessagesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessagesResponse}
 */
proto.walletrpc.SignMessagesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.SignMessagesResponse.SignReply;
      reader.readMessage(value,proto.walletrpc.SignMessagesResponse.SignReply.deserializeBinaryFromReader);
      msg.getRepliesList().push(value);
      msg.setRepliesList(msg.getRepliesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessagesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getRepliesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.SignMessagesResponse.SignReply.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessagesResponse} The clone.
 */
proto.walletrpc.SignMessagesResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessagesResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated SignReply replies = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SignMessagesResponse.SignReply>}
 */
proto.walletrpc.SignMessagesResponse.prototype.getRepliesList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignMessagesResponse.SignReply>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignMessagesResponse.SignReply, 1));
};


/** @param {Array.<!proto.walletrpc.SignMessagesResponse.SignReply>} value  */
proto.walletrpc.SignMessagesResponse.prototype.setRepliesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.SignMessagesResponse.prototype.clearRepliesList = function() {
  this.setRepliesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessagesResponse.SignReply = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessagesResponse.SignReply, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessagesResponse.SignReply.displayName = 'proto.walletrpc.SignMessagesResponse.SignReply';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessagesResponse.SignReply.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessagesResponse.SignReply} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignMessagesResponse.SignReply.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64(),
    error: msg.getError()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessagesResponse.SignReply}
 */
proto.walletrpc.SignMessagesResponse.SignReply.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessagesResponse.SignReply;
  return proto.walletrpc.SignMessagesResponse.SignReply.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessagesResponse.SignReply} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessagesResponse.SignReply}
 */
proto.walletrpc.SignMessagesResponse.SignReply.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setError(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessagesResponse.SignReply} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesResponse.SignReply.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getError();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SignMessagesResponse.SignReply} The clone.
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SignMessagesResponse.SignReply} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string error = 2;
 * @return {string}
 */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.getError = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.SignMessagesResponse.SignReply.prototype.setError = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsRequest.displayName = 'proto.walletrpc.TransactionNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsRequest;
  return proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TransactionNotificationsRequest} The clone.
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TransactionNotificationsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionNotificationsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsResponse.displayName = 'proto.walletrpc.TransactionNotificationsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionNotificationsResponse.repeatedFields_ = [1,2,3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    attachedBlocksList: jspb.Message.toObjectList(msg.getAttachedBlocksList(),
    proto.walletrpc.BlockDetails.toObject, includeInstance),
    detachedBlocksList: msg.getDetachedBlocksList_asB64(),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance),
    unminedTransactionHashesList: msg.getUnminedTransactionHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsResponse;
  return proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.getAttachedBlocksList().push(value);
      msg.setAttachedBlocksList(msg.getAttachedBlocksList());
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.getDetachedBlocksList().push(value);
      msg.setDetachedBlocksList(msg.getDetachedBlocksList());
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.getUnminedTransactionsList().push(value);
      msg.setUnminedTransactionsList(msg.getUnminedTransactionsList());
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.getUnminedTransactionHashesList().push(value);
      msg.setUnminedTransactionHashesList(msg.getUnminedTransactionHashesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAttachedBlocksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = this.getDetachedBlocksList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = this.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = this.getUnminedTransactionHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TransactionNotificationsResponse} The clone.
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TransactionNotificationsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated BlockDetails attached_blocks = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.BlockDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getAttachedBlocksList = function() {
  return /** @type{!Array.<!proto.walletrpc.BlockDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {Array.<!proto.walletrpc.BlockDetails>} value  */
proto.walletrpc.TransactionNotificationsResponse.prototype.setAttachedBlocksList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearAttachedBlocksList = function() {
  this.setAttachedBlocksList([]);
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 2));
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getDetachedBlocksList()));
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getDetachedBlocksList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value  */
proto.walletrpc.TransactionNotificationsResponse.prototype.setDetachedBlocksList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearDetachedBlocksList = function() {
  jspb.Message.setField(this, 2, []);
};


/**
 * repeated TransactionDetails unmined_transactions = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 3));
};


/** @param {Array.<!proto.walletrpc.TransactionDetails>} value  */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 4));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getUnminedTransactionHashesList()));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getUnminedTransactionHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value  */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionHashesList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionHashesList = function() {
  jspb.Message.setField(this, 4, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsRequest.displayName = 'proto.walletrpc.AccountNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsRequest;
  return proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountNotificationsRequest} The clone.
 */
proto.walletrpc.AccountNotificationsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountNotificationsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsResponse.displayName = 'proto.walletrpc.AccountNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber(),
    accountName: msg.getAccountName(),
    externalKeyCount: msg.getExternalKeyCount(),
    internalKeyCount: msg.getInternalKeyCount(),
    importedKeyCount: msg.getImportedKeyCount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsResponse;
  return proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AccountNotificationsResponse} The clone.
 */
proto.walletrpc.AccountNotificationsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AccountNotificationsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 external_key_count = 3;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountNotificationsResponse.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 internal_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountNotificationsResponse.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 imported_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.AccountNotificationsResponse.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConfirmationNotificationsRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsRequest.displayName = 'proto.walletrpc.ConfirmationNotificationsRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConfirmationNotificationsRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    txHashesList: msg.getTxHashesList_asB64(),
    stopAfter: msg.getStopAfter()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsRequest}
 */
proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsRequest;
  return proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsRequest}
 */
proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.getTxHashesList().push(value);
      msg.setTxHashesList(msg.getTxHashesList());
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setStopAfter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTxHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
  f = this.getStopAfter();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConfirmationNotificationsRequest} The clone.
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConfirmationNotificationsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated bytes tx_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 1));
};


/**
 * repeated bytes tx_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getTxHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTxHashesList()));
};


/**
 * repeated bytes tx_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTxHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value  */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.setTxHashesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


proto.walletrpc.ConfirmationNotificationsRequest.prototype.clearTxHashesList = function() {
  jspb.Message.setField(this, 1, []);
};


/**
 * optional int32 stop_after = 2;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getStopAfter = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.setStopAfter = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConfirmationNotificationsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsResponse.displayName = 'proto.walletrpc.ConfirmationNotificationsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConfirmationNotificationsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    confirmationsList: jspb.Message.toObjectList(msg.getConfirmationsList(),
    proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse}
 */
proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsResponse;
  return proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse}
 */
proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations;
      reader.readMessage(value,proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader);
      msg.getConfirmationsList().push(value);
      msg.setConfirmationsList(msg.getConfirmationsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getConfirmationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse} The clone.
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConfirmationNotificationsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated TransactionConfirmations confirmations = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.getConfirmationsList = function() {
  return /** @type{!Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations, 1));
};


/** @param {Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>} value  */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.setConfirmationsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.ConfirmationNotificationsResponse.prototype.clearConfirmationsList = function() {
  this.setConfirmationsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.displayName = 'proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject = function(includeInstance, msg) {
  var f, obj = {
    txHash: msg.getTxHash_asB64(),
    confirmations: msg.getConfirmations(),
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: msg.getBlockHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations;
  return proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setConfirmations(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTxHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} The clone.
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes tx_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes tx_hash = 1;
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {string}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxHash()));
};


/**
 * optional bytes tx_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setTxHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 confirmations = 2;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes block_hash = 3;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 block_height = 4;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletRequest.displayName = 'proto.walletrpc.CreateWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64(),
    privatePassphrase: msg.getPrivatePassphrase_asB64(),
    seed: msg.getSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletRequest;
  return proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateWalletRequest} The clone.
 */
proto.walletrpc.CreateWalletRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateWalletRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateWalletRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes seed = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes seed = 3;
 * This is a type-conversion wrapper around `getSeed()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeed()));
};


/**
 * optional bytes seed = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeed()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateWalletRequest.prototype.setSeed = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletResponse.displayName = 'proto.walletrpc.CreateWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletResponse;
  return proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateWalletResponse} The clone.
 */
proto.walletrpc.CreateWalletResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateWalletResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWatchingOnlyWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWatchingOnlyWalletRequest.displayName = 'proto.walletrpc.CreateWatchingOnlyWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWatchingOnlyWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    extendedPubKey: msg.getExtendedPubKey(),
    publicPassphrase: msg.getPublicPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletRequest}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWatchingOnlyWalletRequest;
  return proto.walletrpc.CreateWatchingOnlyWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletRequest}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setExtendedPubKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getExtendedPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletRequest} The clone.
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateWatchingOnlyWalletRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string extended_pub_key = 1;
 * @return {string}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.getExtendedPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.setExtendedPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes public_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes public_passphrase = 2;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CreateWatchingOnlyWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWatchingOnlyWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWatchingOnlyWalletResponse.displayName = 'proto.walletrpc.CreateWatchingOnlyWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWatchingOnlyWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletResponse}
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWatchingOnlyWalletResponse;
  return proto.walletrpc.CreateWatchingOnlyWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletResponse}
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWatchingOnlyWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CreateWatchingOnlyWalletResponse} The clone.
 */
proto.walletrpc.CreateWatchingOnlyWalletResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CreateWatchingOnlyWalletResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletRequest.displayName = 'proto.walletrpc.OpenWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.OpenWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletRequest;
  return proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.OpenWalletRequest} The clone.
 */
proto.walletrpc.OpenWalletRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.OpenWalletRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.OpenWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletResponse.displayName = 'proto.walletrpc.OpenWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.OpenWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    watchingOnly: msg.getWatchingOnly()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletResponse;
  return proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setWatchingOnly(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getWatchingOnly();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.OpenWalletResponse} The clone.
 */
proto.walletrpc.OpenWalletResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.OpenWalletResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool watching_only = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.OpenWalletResponse.prototype.getWatchingOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.OpenWalletResponse.prototype.setWatchingOnly = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletRequest.displayName = 'proto.walletrpc.CloseWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CloseWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletRequest;
  return proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CloseWalletRequest} The clone.
 */
proto.walletrpc.CloseWalletRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CloseWalletRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletResponse.displayName = 'proto.walletrpc.CloseWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CloseWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletResponse;
  return proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CloseWalletResponse} The clone.
 */
proto.walletrpc.CloseWalletResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CloseWalletResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsRequest.displayName = 'proto.walletrpc.WalletExistsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.WalletExistsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsRequest;
  return proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.WalletExistsRequest} The clone.
 */
proto.walletrpc.WalletExistsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.WalletExistsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsResponse.displayName = 'proto.walletrpc.WalletExistsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.WalletExistsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    exists: msg.getExists()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsResponse;
  return proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setExists(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getExists();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.WalletExistsResponse} The clone.
 */
proto.walletrpc.WalletExistsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.WalletExistsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool exists = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.WalletExistsResponse.prototype.getExists = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.WalletExistsResponse.prototype.setExists = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcRequest.displayName = 'proto.walletrpc.StartConsensusRpcRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    networkAddress: msg.getNetworkAddress(),
    username: msg.getUsername(),
    password: msg.getPassword_asB64(),
    certificate: msg.getCertificate_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcRequest;
  return proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetworkAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassword(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCertificate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getNetworkAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getUsername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getCertificate_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StartConsensusRpcRequest} The clone.
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StartConsensusRpcRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string network_address = 1;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getNetworkAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.StartConsensusRpcRequest.prototype.setNetworkAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string username = 2;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.StartConsensusRpcRequest.prototype.setUsername = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes password = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes password = 3;
 * This is a type-conversion wrapper around `getPassword()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassword()));
};


/**
 * optional bytes password = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassword()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassword()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.StartConsensusRpcRequest.prototype.setPassword = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes certificate = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes certificate = 4;
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCertificate()));
};


/**
 * optional bytes certificate = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCertificate()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.StartConsensusRpcRequest.prototype.setCertificate = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcResponse.displayName = 'proto.walletrpc.StartConsensusRpcResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcResponse;
  return proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StartConsensusRpcResponse} The clone.
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StartConsensusRpcResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesRequest.displayName = 'proto.walletrpc.DiscoverAddressesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    discoverAccounts: msg.getDiscoverAccounts(),
    privatePassphrase: msg.getPrivatePassphrase_asB64(),
    startingBlockHash: msg.getStartingBlockHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesRequest;
  return proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDiscoverAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDiscoverAccounts();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DiscoverAddressesRequest} The clone.
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DiscoverAddressesRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool discover_accounts = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getDiscoverAccounts = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.DiscoverAddressesRequest.prototype.setDiscoverAccounts = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DiscoverAddressesRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes starting_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes starting_block_hash = 3;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DiscoverAddressesRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesResponse.displayName = 'proto.walletrpc.DiscoverAddressesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesResponse;
  return proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DiscoverAddressesResponse} The clone.
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DiscoverAddressesResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchMissingCFiltersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchMissingCFiltersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchMissingCFiltersRequest.displayName = 'proto.walletrpc.FetchMissingCFiltersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchMissingCFiltersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchMissingCFiltersRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchMissingCFiltersRequest}
 */
proto.walletrpc.FetchMissingCFiltersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchMissingCFiltersRequest;
  return proto.walletrpc.FetchMissingCFiltersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchMissingCFiltersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchMissingCFiltersRequest}
 */
proto.walletrpc.FetchMissingCFiltersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchMissingCFiltersRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchMissingCFiltersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchMissingCFiltersRequest} The clone.
 */
proto.walletrpc.FetchMissingCFiltersRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchMissingCFiltersRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchMissingCFiltersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchMissingCFiltersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchMissingCFiltersResponse.displayName = 'proto.walletrpc.FetchMissingCFiltersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchMissingCFiltersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchMissingCFiltersResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchMissingCFiltersResponse}
 */
proto.walletrpc.FetchMissingCFiltersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchMissingCFiltersResponse;
  return proto.walletrpc.FetchMissingCFiltersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchMissingCFiltersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchMissingCFiltersResponse}
 */
proto.walletrpc.FetchMissingCFiltersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchMissingCFiltersResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchMissingCFiltersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchMissingCFiltersResponse} The clone.
 */
proto.walletrpc.FetchMissingCFiltersResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchMissingCFiltersResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsRequest.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsRequest;
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest} The clone.
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SubscribeToBlockNotificationsRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsResponse.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsResponse;
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse} The clone.
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SubscribeToBlockNotificationsResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersRequest.displayName = 'proto.walletrpc.FetchHeadersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersRequest;
  return proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchHeadersRequest} The clone.
 */
proto.walletrpc.FetchHeadersRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchHeadersRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersResponse.displayName = 'proto.walletrpc.FetchHeadersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    fetchedHeadersCount: msg.getFetchedHeadersCount(),
    firstNewBlockHash: msg.getFirstNewBlockHash_asB64(),
    firstNewBlockHeight: msg.getFirstNewBlockHeight(),
    mainChainTipBlockHash: msg.getMainChainTipBlockHash_asB64(),
    mainChainTipBlockHeight: msg.getMainChainTipBlockHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersResponse;
  return proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFetchedHeadersCount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFirstNewBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFirstNewBlockHeight(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMainChainTipBlockHash(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMainChainTipBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getFetchedHeadersCount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getFirstNewBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getFirstNewBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getMainChainTipBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getMainChainTipBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchHeadersResponse} The clone.
 */
proto.walletrpc.FetchHeadersResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchHeadersResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 fetched_headers_count = 1;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFetchedHeadersCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchHeadersResponse.prototype.setFetchedHeadersCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes first_new_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes first_new_block_hash = 2;
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFirstNewBlockHash()));
};


/**
 * optional bytes first_new_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFirstNewBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 first_new_block_height = 3;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMainChainTipBlockHash()));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMainChainTipBlockHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 main_chain_tip_block_height = 5;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHeight = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersNotification.displayName = 'proto.walletrpc.FetchHeadersNotification';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersNotification} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    fetchedHeadersCount: msg.getFetchedHeadersCount(),
    lastHeaderTime: msg.getLastHeaderTime()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersNotification}
 */
proto.walletrpc.FetchHeadersNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersNotification;
  return proto.walletrpc.FetchHeadersNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersNotification}
 */
proto.walletrpc.FetchHeadersNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFetchedHeadersCount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLastHeaderTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersNotification} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersNotification.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersNotification.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getFetchedHeadersCount();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = this.getLastHeaderTime();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchHeadersNotification} The clone.
 */
proto.walletrpc.FetchHeadersNotification.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchHeadersNotification} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 fetched_headers_count = 1;
 * @return {number}
 */
proto.walletrpc.FetchHeadersNotification.prototype.getFetchedHeadersCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchHeadersNotification.prototype.setFetchedHeadersCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 last_header_time = 2;
 * @return {number}
 */
proto.walletrpc.FetchHeadersNotification.prototype.getLastHeaderTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchHeadersNotification.prototype.setLastHeaderTime = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchMissingCFiltersNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchMissingCFiltersNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchMissingCFiltersNotification.displayName = 'proto.walletrpc.FetchMissingCFiltersNotification';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchMissingCFiltersNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchMissingCFiltersNotification} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchMissingCFiltersNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    fetchedCfiltersStartHeight: msg.getFetchedCfiltersStartHeight(),
    fetchedCfiltersEndHeight: msg.getFetchedCfiltersEndHeight()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchMissingCFiltersNotification}
 */
proto.walletrpc.FetchMissingCFiltersNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchMissingCFiltersNotification;
  return proto.walletrpc.FetchMissingCFiltersNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchMissingCFiltersNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchMissingCFiltersNotification}
 */
proto.walletrpc.FetchMissingCFiltersNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFetchedCfiltersStartHeight(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFetchedCfiltersEndHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchMissingCFiltersNotification} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersNotification.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getFetchedCfiltersStartHeight();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = this.getFetchedCfiltersEndHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.FetchMissingCFiltersNotification} The clone.
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.FetchMissingCFiltersNotification} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 fetched_cfilters_start_height = 1;
 * @return {number}
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.getFetchedCfiltersStartHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.setFetchedCfiltersStartHeight = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 fetched_cfilters_end_height = 2;
 * @return {number}
 */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.getFetchedCfiltersEndHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.FetchMissingCFiltersNotification.prototype.setFetchedCfiltersEndHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanProgressNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanProgressNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanProgressNotification.displayName = 'proto.walletrpc.RescanProgressNotification';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanProgressNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanProgressNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanProgressNotification} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanProgressNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    rescannedThrough: msg.getRescannedThrough()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanProgressNotification}
 */
proto.walletrpc.RescanProgressNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanProgressNotification;
  return proto.walletrpc.RescanProgressNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanProgressNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanProgressNotification}
 */
proto.walletrpc.RescanProgressNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRescannedThrough(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanProgressNotification} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanProgressNotification.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanProgressNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanProgressNotification.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getRescannedThrough();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RescanProgressNotification} The clone.
 */
proto.walletrpc.RescanProgressNotification.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RescanProgressNotification} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 rescanned_through = 1;
 * @return {number}
 */
proto.walletrpc.RescanProgressNotification.prototype.getRescannedThrough = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.RescanProgressNotification.prototype.setRescannedThrough = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PeerNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PeerNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PeerNotification.displayName = 'proto.walletrpc.PeerNotification';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PeerNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PeerNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PeerNotification} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PeerNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    peerCount: msg.getPeerCount(),
    address: msg.getAddress()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PeerNotification}
 */
proto.walletrpc.PeerNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PeerNotification;
  return proto.walletrpc.PeerNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PeerNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PeerNotification}
 */
proto.walletrpc.PeerNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPeerCount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PeerNotification} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PeerNotification.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PeerNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PeerNotification.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPeerCount();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.PeerNotification} The clone.
 */
proto.walletrpc.PeerNotification.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.PeerNotification} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int32 peer_count = 1;
 * @return {number}
 */
proto.walletrpc.PeerNotification.prototype.getPeerCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.PeerNotification.prototype.setPeerCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.walletrpc.PeerNotification.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.PeerNotification.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RpcSyncRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RpcSyncRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RpcSyncRequest.displayName = 'proto.walletrpc.RpcSyncRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RpcSyncRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RpcSyncRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RpcSyncRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RpcSyncRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    networkAddress: msg.getNetworkAddress(),
    username: msg.getUsername(),
    password: msg.getPassword_asB64(),
    certificate: msg.getCertificate_asB64(),
    discoverAccounts: msg.getDiscoverAccounts(),
    privatePassphrase: msg.getPrivatePassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RpcSyncRequest}
 */
proto.walletrpc.RpcSyncRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RpcSyncRequest;
  return proto.walletrpc.RpcSyncRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RpcSyncRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RpcSyncRequest}
 */
proto.walletrpc.RpcSyncRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetworkAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassword(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCertificate(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDiscoverAccounts(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RpcSyncRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RpcSyncRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RpcSyncRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RpcSyncRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getNetworkAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getUsername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getCertificate_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getDiscoverAccounts();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RpcSyncRequest} The clone.
 */
proto.walletrpc.RpcSyncRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RpcSyncRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string network_address = 1;
 * @return {string}
 */
proto.walletrpc.RpcSyncRequest.prototype.getNetworkAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.RpcSyncRequest.prototype.setNetworkAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string username = 2;
 * @return {string}
 */
proto.walletrpc.RpcSyncRequest.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.RpcSyncRequest.prototype.setUsername = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes password = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes password = 3;
 * This is a type-conversion wrapper around `getPassword()`
 * @return {string}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassword()));
};


/**
 * optional bytes password = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassword()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassword()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RpcSyncRequest.prototype.setPassword = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes certificate = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RpcSyncRequest.prototype.getCertificate = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes certificate = 4;
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {string}
 */
proto.walletrpc.RpcSyncRequest.prototype.getCertificate_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCertificate()));
};


/**
 * optional bytes certificate = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RpcSyncRequest.prototype.getCertificate_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCertificate()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RpcSyncRequest.prototype.setCertificate = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool discover_accounts = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.RpcSyncRequest.prototype.getDiscoverAccounts = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 5, false));
};


/** @param {boolean} value  */
proto.walletrpc.RpcSyncRequest.prototype.setDiscoverAccounts = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bytes private_passphrase = 6;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 6, ""));
};


/**
 * optional bytes private_passphrase = 6;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RpcSyncRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RpcSyncRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RpcSyncResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RpcSyncResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RpcSyncResponse.displayName = 'proto.walletrpc.RpcSyncResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RpcSyncResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RpcSyncResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RpcSyncResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RpcSyncResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    synced: msg.getSynced(),
    notificationType: msg.getNotificationType(),
    fetchHeaders: (f = msg.getFetchHeaders()) && proto.walletrpc.FetchHeadersNotification.toObject(includeInstance, f),
    fetchMissingCfilters: (f = msg.getFetchMissingCfilters()) && proto.walletrpc.FetchMissingCFiltersNotification.toObject(includeInstance, f),
    rescanProgress: (f = msg.getRescanProgress()) && proto.walletrpc.RescanProgressNotification.toObject(includeInstance, f),
    peerInformation: (f = msg.getPeerInformation()) && proto.walletrpc.PeerNotification.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RpcSyncResponse}
 */
proto.walletrpc.RpcSyncResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RpcSyncResponse;
  return proto.walletrpc.RpcSyncResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RpcSyncResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RpcSyncResponse}
 */
proto.walletrpc.RpcSyncResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSynced(value);
      break;
    case 2:
      var value = /** @type {!proto.walletrpc.SyncNotificationType} */ (reader.readEnum());
      msg.setNotificationType(value);
      break;
    case 3:
      var value = new proto.walletrpc.FetchHeadersNotification;
      reader.readMessage(value,proto.walletrpc.FetchHeadersNotification.deserializeBinaryFromReader);
      msg.setFetchHeaders(value);
      break;
    case 4:
      var value = new proto.walletrpc.FetchMissingCFiltersNotification;
      reader.readMessage(value,proto.walletrpc.FetchMissingCFiltersNotification.deserializeBinaryFromReader);
      msg.setFetchMissingCfilters(value);
      break;
    case 5:
      var value = new proto.walletrpc.RescanProgressNotification;
      reader.readMessage(value,proto.walletrpc.RescanProgressNotification.deserializeBinaryFromReader);
      msg.setRescanProgress(value);
      break;
    case 6:
      var value = new proto.walletrpc.PeerNotification;
      reader.readMessage(value,proto.walletrpc.PeerNotification.deserializeBinaryFromReader);
      msg.setPeerInformation(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RpcSyncResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RpcSyncResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RpcSyncResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RpcSyncResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSynced();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getNotificationType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = this.getFetchHeaders();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.walletrpc.FetchHeadersNotification.serializeBinaryToWriter
    );
  }
  f = this.getFetchMissingCfilters();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.walletrpc.FetchMissingCFiltersNotification.serializeBinaryToWriter
    );
  }
  f = this.getRescanProgress();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.walletrpc.RescanProgressNotification.serializeBinaryToWriter
    );
  }
  f = this.getPeerInformation();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.walletrpc.PeerNotification.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RpcSyncResponse} The clone.
 */
proto.walletrpc.RpcSyncResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RpcSyncResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool synced = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.RpcSyncResponse.prototype.getSynced = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.RpcSyncResponse.prototype.setSynced = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional SyncNotificationType notification_type = 2;
 * @return {!proto.walletrpc.SyncNotificationType}
 */
proto.walletrpc.RpcSyncResponse.prototype.getNotificationType = function() {
  return /** @type {!proto.walletrpc.SyncNotificationType} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {!proto.walletrpc.SyncNotificationType} value  */
proto.walletrpc.RpcSyncResponse.prototype.setNotificationType = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional FetchHeadersNotification fetch_headers = 3;
 * @return {proto.walletrpc.FetchHeadersNotification}
 */
proto.walletrpc.RpcSyncResponse.prototype.getFetchHeaders = function() {
  return /** @type{proto.walletrpc.FetchHeadersNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.FetchHeadersNotification, 3));
};


/** @param {proto.walletrpc.FetchHeadersNotification|undefined} value  */
proto.walletrpc.RpcSyncResponse.prototype.setFetchHeaders = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.walletrpc.RpcSyncResponse.prototype.clearFetchHeaders = function() {
  this.setFetchHeaders(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.RpcSyncResponse.prototype.hasFetchHeaders = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional FetchMissingCFiltersNotification fetch_missing_cfilters = 4;
 * @return {proto.walletrpc.FetchMissingCFiltersNotification}
 */
proto.walletrpc.RpcSyncResponse.prototype.getFetchMissingCfilters = function() {
  return /** @type{proto.walletrpc.FetchMissingCFiltersNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.FetchMissingCFiltersNotification, 4));
};


/** @param {proto.walletrpc.FetchMissingCFiltersNotification|undefined} value  */
proto.walletrpc.RpcSyncResponse.prototype.setFetchMissingCfilters = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.walletrpc.RpcSyncResponse.prototype.clearFetchMissingCfilters = function() {
  this.setFetchMissingCfilters(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.RpcSyncResponse.prototype.hasFetchMissingCfilters = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RescanProgressNotification rescan_progress = 5;
 * @return {proto.walletrpc.RescanProgressNotification}
 */
proto.walletrpc.RpcSyncResponse.prototype.getRescanProgress = function() {
  return /** @type{proto.walletrpc.RescanProgressNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.RescanProgressNotification, 5));
};


/** @param {proto.walletrpc.RescanProgressNotification|undefined} value  */
proto.walletrpc.RpcSyncResponse.prototype.setRescanProgress = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.walletrpc.RpcSyncResponse.prototype.clearRescanProgress = function() {
  this.setRescanProgress(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.RpcSyncResponse.prototype.hasRescanProgress = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional PeerNotification peer_information = 6;
 * @return {proto.walletrpc.PeerNotification}
 */
proto.walletrpc.RpcSyncResponse.prototype.getPeerInformation = function() {
  return /** @type{proto.walletrpc.PeerNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.PeerNotification, 6));
};


/** @param {proto.walletrpc.PeerNotification|undefined} value  */
proto.walletrpc.RpcSyncResponse.prototype.setPeerInformation = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.walletrpc.RpcSyncResponse.prototype.clearPeerInformation = function() {
  this.setPeerInformation(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.RpcSyncResponse.prototype.hasPeerInformation = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SpvSyncRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SpvSyncRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SpvSyncRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SpvSyncRequest.displayName = 'proto.walletrpc.SpvSyncRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SpvSyncRequest.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SpvSyncRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SpvSyncRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SpvSyncRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SpvSyncRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    discoverAccounts: msg.getDiscoverAccounts(),
    privatePassphrase: msg.getPrivatePassphrase_asB64(),
    spvConnectList: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SpvSyncRequest}
 */
proto.walletrpc.SpvSyncRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SpvSyncRequest;
  return proto.walletrpc.SpvSyncRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SpvSyncRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SpvSyncRequest}
 */
proto.walletrpc.SpvSyncRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDiscoverAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.getSpvConnectList().push(value);
      msg.setSpvConnectList(msg.getSpvConnectList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SpvSyncRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpvSyncRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SpvSyncRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpvSyncRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDiscoverAccounts();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getSpvConnectList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SpvSyncRequest} The clone.
 */
proto.walletrpc.SpvSyncRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SpvSyncRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool discover_accounts = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.SpvSyncRequest.prototype.getDiscoverAccounts = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.SpvSyncRequest.prototype.setDiscoverAccounts = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SpvSyncRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.SpvSyncRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SpvSyncRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SpvSyncRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated string spv_connect = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
proto.walletrpc.SpvSyncRequest.prototype.getSpvConnectList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getField(this, 3));
};


/** @param {Array.<string>} value  */
proto.walletrpc.SpvSyncRequest.prototype.setSpvConnectList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


proto.walletrpc.SpvSyncRequest.prototype.clearSpvConnectList = function() {
  jspb.Message.setField(this, 3, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SpvSyncResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SpvSyncResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SpvSyncResponse.displayName = 'proto.walletrpc.SpvSyncResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SpvSyncResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SpvSyncResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SpvSyncResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SpvSyncResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    synced: msg.getSynced(),
    notificationType: msg.getNotificationType(),
    fetchHeaders: (f = msg.getFetchHeaders()) && proto.walletrpc.FetchHeadersNotification.toObject(includeInstance, f),
    fetchMissingCfilters: (f = msg.getFetchMissingCfilters()) && proto.walletrpc.FetchMissingCFiltersNotification.toObject(includeInstance, f),
    rescanProgress: (f = msg.getRescanProgress()) && proto.walletrpc.RescanProgressNotification.toObject(includeInstance, f),
    peerInformation: (f = msg.getPeerInformation()) && proto.walletrpc.PeerNotification.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SpvSyncResponse}
 */
proto.walletrpc.SpvSyncResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SpvSyncResponse;
  return proto.walletrpc.SpvSyncResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SpvSyncResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SpvSyncResponse}
 */
proto.walletrpc.SpvSyncResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSynced(value);
      break;
    case 2:
      var value = /** @type {!proto.walletrpc.SyncNotificationType} */ (reader.readEnum());
      msg.setNotificationType(value);
      break;
    case 3:
      var value = new proto.walletrpc.FetchHeadersNotification;
      reader.readMessage(value,proto.walletrpc.FetchHeadersNotification.deserializeBinaryFromReader);
      msg.setFetchHeaders(value);
      break;
    case 4:
      var value = new proto.walletrpc.FetchMissingCFiltersNotification;
      reader.readMessage(value,proto.walletrpc.FetchMissingCFiltersNotification.deserializeBinaryFromReader);
      msg.setFetchMissingCfilters(value);
      break;
    case 5:
      var value = new proto.walletrpc.RescanProgressNotification;
      reader.readMessage(value,proto.walletrpc.RescanProgressNotification.deserializeBinaryFromReader);
      msg.setRescanProgress(value);
      break;
    case 6:
      var value = new proto.walletrpc.PeerNotification;
      reader.readMessage(value,proto.walletrpc.PeerNotification.deserializeBinaryFromReader);
      msg.setPeerInformation(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SpvSyncResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpvSyncResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SpvSyncResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpvSyncResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSynced();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getNotificationType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = this.getFetchHeaders();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.walletrpc.FetchHeadersNotification.serializeBinaryToWriter
    );
  }
  f = this.getFetchMissingCfilters();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.walletrpc.FetchMissingCFiltersNotification.serializeBinaryToWriter
    );
  }
  f = this.getRescanProgress();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.walletrpc.RescanProgressNotification.serializeBinaryToWriter
    );
  }
  f = this.getPeerInformation();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.walletrpc.PeerNotification.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SpvSyncResponse} The clone.
 */
proto.walletrpc.SpvSyncResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SpvSyncResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool synced = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.SpvSyncResponse.prototype.getSynced = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.SpvSyncResponse.prototype.setSynced = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional SyncNotificationType notification_type = 2;
 * @return {!proto.walletrpc.SyncNotificationType}
 */
proto.walletrpc.SpvSyncResponse.prototype.getNotificationType = function() {
  return /** @type {!proto.walletrpc.SyncNotificationType} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {!proto.walletrpc.SyncNotificationType} value  */
proto.walletrpc.SpvSyncResponse.prototype.setNotificationType = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional FetchHeadersNotification fetch_headers = 3;
 * @return {proto.walletrpc.FetchHeadersNotification}
 */
proto.walletrpc.SpvSyncResponse.prototype.getFetchHeaders = function() {
  return /** @type{proto.walletrpc.FetchHeadersNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.FetchHeadersNotification, 3));
};


/** @param {proto.walletrpc.FetchHeadersNotification|undefined} value  */
proto.walletrpc.SpvSyncResponse.prototype.setFetchHeaders = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.walletrpc.SpvSyncResponse.prototype.clearFetchHeaders = function() {
  this.setFetchHeaders(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.SpvSyncResponse.prototype.hasFetchHeaders = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional FetchMissingCFiltersNotification fetch_missing_cfilters = 4;
 * @return {proto.walletrpc.FetchMissingCFiltersNotification}
 */
proto.walletrpc.SpvSyncResponse.prototype.getFetchMissingCfilters = function() {
  return /** @type{proto.walletrpc.FetchMissingCFiltersNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.FetchMissingCFiltersNotification, 4));
};


/** @param {proto.walletrpc.FetchMissingCFiltersNotification|undefined} value  */
proto.walletrpc.SpvSyncResponse.prototype.setFetchMissingCfilters = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.walletrpc.SpvSyncResponse.prototype.clearFetchMissingCfilters = function() {
  this.setFetchMissingCfilters(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.SpvSyncResponse.prototype.hasFetchMissingCfilters = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RescanProgressNotification rescan_progress = 5;
 * @return {proto.walletrpc.RescanProgressNotification}
 */
proto.walletrpc.SpvSyncResponse.prototype.getRescanProgress = function() {
  return /** @type{proto.walletrpc.RescanProgressNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.RescanProgressNotification, 5));
};


/** @param {proto.walletrpc.RescanProgressNotification|undefined} value  */
proto.walletrpc.SpvSyncResponse.prototype.setRescanProgress = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.walletrpc.SpvSyncResponse.prototype.clearRescanProgress = function() {
  this.setRescanProgress(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.SpvSyncResponse.prototype.hasRescanProgress = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional PeerNotification peer_information = 6;
 * @return {proto.walletrpc.PeerNotification}
 */
proto.walletrpc.SpvSyncResponse.prototype.getPeerInformation = function() {
  return /** @type{proto.walletrpc.PeerNotification} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.PeerNotification, 6));
};


/** @param {proto.walletrpc.PeerNotification|undefined} value  */
proto.walletrpc.SpvSyncResponse.prototype.setPeerInformation = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.walletrpc.SpvSyncResponse.prototype.clearPeerInformation = function() {
  this.setPeerInformation(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.SpvSyncResponse.prototype.hasPeerInformation = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanPointRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanPointRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanPointRequest.displayName = 'proto.walletrpc.RescanPointRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanPointRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanPointRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanPointRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanPointRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanPointRequest}
 */
proto.walletrpc.RescanPointRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanPointRequest;
  return proto.walletrpc.RescanPointRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanPointRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanPointRequest}
 */
proto.walletrpc.RescanPointRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanPointRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanPointRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanPointRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanPointRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RescanPointRequest} The clone.
 */
proto.walletrpc.RescanPointRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RescanPointRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanPointResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanPointResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanPointResponse.displayName = 'proto.walletrpc.RescanPointResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanPointResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanPointResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanPointResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanPointResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    rescanPointHash: msg.getRescanPointHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanPointResponse}
 */
proto.walletrpc.RescanPointResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanPointResponse;
  return proto.walletrpc.RescanPointResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanPointResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanPointResponse}
 */
proto.walletrpc.RescanPointResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRescanPointHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanPointResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanPointResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanPointResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanPointResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getRescanPointHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RescanPointResponse} The clone.
 */
proto.walletrpc.RescanPointResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RescanPointResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes rescan_point_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RescanPointResponse.prototype.getRescanPointHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes rescan_point_hash = 1;
 * This is a type-conversion wrapper around `getRescanPointHash()`
 * @return {string}
 */
proto.walletrpc.RescanPointResponse.prototype.getRescanPointHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRescanPointHash()));
};


/**
 * optional bytes rescan_point_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRescanPointHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanPointResponse.prototype.getRescanPointHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRescanPointHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RescanPointResponse.prototype.setRescanPointHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedRequest.displayName = 'proto.walletrpc.GenerateRandomSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedLength: msg.getSeedLength()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedRequest;
  return proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSeedLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSeedLength();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest} The clone.
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GenerateRandomSeedRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 seed_length = 1;
 * @return {number}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.getSeedLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.GenerateRandomSeedRequest.prototype.setSeedLength = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedResponse.displayName = 'proto.walletrpc.GenerateRandomSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedBytes: msg.getSeedBytes_asB64(),
    seedHex: msg.getSeedHex(),
    seedMnemonic: msg.getSeedMnemonic()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedResponse;
  return proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeedBytes(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedHex(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedMnemonic(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSeedBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getSeedHex();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getSeedMnemonic();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse} The clone.
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GenerateRandomSeedResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes seed_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes seed_bytes = 1;
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeedBytes()));
};


/**
 * optional bytes seed_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeedBytes()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedBytes = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string seed_hex = 2;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedHex = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedHex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string seed_mnemonic = 3;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedMnemonic = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/** @param {string} value  */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedMnemonic = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedRequest.displayName = 'proto.walletrpc.DecodeSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userInput: msg.getUserInput()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedRequest;
  return proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserInput(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getUserInput();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodeSeedRequest} The clone.
 */
proto.walletrpc.DecodeSeedRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodeSeedRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string user_input = 1;
 * @return {string}
 */
proto.walletrpc.DecodeSeedRequest.prototype.getUserInput = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.DecodeSeedRequest.prototype.setUserInput = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedResponse.displayName = 'proto.walletrpc.DecodeSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    decodedSeed: msg.getDecodedSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedResponse;
  return proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDecodedSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDecodedSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodeSeedResponse} The clone.
 */
proto.walletrpc.DecodeSeedResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodeSeedResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes decoded_seed = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes decoded_seed = 1;
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {string}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDecodedSeed()));
};


/**
 * optional bytes decoded_seed = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDecodedSeed()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodeSeedResponse.prototype.setDecodedSeed = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RunTicketBuyerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RunTicketBuyerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RunTicketBuyerRequest.displayName = 'proto.walletrpc.RunTicketBuyerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RunTicketBuyerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RunTicketBuyerRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RunTicketBuyerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: msg.getAccount(),
    votingAccount: msg.getVotingAccount(),
    balanceToMaintain: msg.getBalanceToMaintain(),
    votingAddress: msg.getVotingAddress(),
    poolAddress: msg.getPoolAddress(),
    poolFees: msg.getPoolFees()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RunTicketBuyerRequest}
 */
proto.walletrpc.RunTicketBuyerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RunTicketBuyerRequest;
  return proto.walletrpc.RunTicketBuyerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RunTicketBuyerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RunTicketBuyerRequest}
 */
proto.walletrpc.RunTicketBuyerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVotingAccount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RunTicketBuyerRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RunTicketBuyerRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getVotingAccount();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      7,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RunTicketBuyerRequest} The clone.
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RunTicketBuyerRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 voting_account = 3;
 * @return {number}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getVotingAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setVotingAccount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 balance_to_maintain = 4;
 * @return {number}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string voting_address = 5;
 * @return {string}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/** @param {string} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string pool_address = 6;
 * @return {string}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 6, ""));
};


/** @param {string} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional double pool_fees = 7;
 * @return {number}
 */
proto.walletrpc.RunTicketBuyerRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.RunTicketBuyerRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RunTicketBuyerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RunTicketBuyerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RunTicketBuyerResponse.displayName = 'proto.walletrpc.RunTicketBuyerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RunTicketBuyerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RunTicketBuyerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RunTicketBuyerResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RunTicketBuyerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RunTicketBuyerResponse}
 */
proto.walletrpc.RunTicketBuyerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RunTicketBuyerResponse;
  return proto.walletrpc.RunTicketBuyerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RunTicketBuyerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RunTicketBuyerResponse}
 */
proto.walletrpc.RunTicketBuyerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RunTicketBuyerResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RunTicketBuyerResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RunTicketBuyerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RunTicketBuyerResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.RunTicketBuyerResponse} The clone.
 */
proto.walletrpc.RunTicketBuyerResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.RunTicketBuyerResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartAutoBuyerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartAutoBuyerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartAutoBuyerRequest.displayName = 'proto.walletrpc.StartAutoBuyerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartAutoBuyerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartAutoBuyerRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: msg.getAccount(),
    balanceToMaintain: msg.getBalanceToMaintain(),
    maxFeePerKb: msg.getMaxFeePerKb(),
    maxPriceRelative: msg.getMaxPriceRelative(),
    maxPriceAbsolute: msg.getMaxPriceAbsolute(),
    votingAddress: msg.getVotingAddress(),
    poolAddress: msg.getPoolAddress(),
    poolFees: msg.getPoolFees(),
    maxPerBlock: msg.getMaxPerBlock()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartAutoBuyerRequest}
 */
proto.walletrpc.StartAutoBuyerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartAutoBuyerRequest;
  return proto.walletrpc.StartAutoBuyerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartAutoBuyerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartAutoBuyerRequest}
 */
proto.walletrpc.StartAutoBuyerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFeePerKb(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartAutoBuyerRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartAutoBuyerRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getMaxFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      5,
      f
    );
  }
  f = this.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = this.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      9,
      f
    );
  }
  f = this.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StartAutoBuyerRequest} The clone.
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StartAutoBuyerRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 balance_to_maintain = 3;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 max_fee_per_kb = 4;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxFeePerKb = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional double max_price_relative = 5;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 max_price_absolute = 6;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string voting_address = 7;
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 7, ""));
};


/** @param {string} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string pool_address = 8;
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 8, ""));
};


/** @param {string} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional double pool_fees = 9;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 9, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 max_per_block = 10;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 10, 0));
};


/** @param {number} value  */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartAutoBuyerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartAutoBuyerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartAutoBuyerResponse.displayName = 'proto.walletrpc.StartAutoBuyerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartAutoBuyerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartAutoBuyerResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartAutoBuyerResponse}
 */
proto.walletrpc.StartAutoBuyerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartAutoBuyerResponse;
  return proto.walletrpc.StartAutoBuyerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartAutoBuyerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartAutoBuyerResponse}
 */
proto.walletrpc.StartAutoBuyerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartAutoBuyerResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartAutoBuyerResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StartAutoBuyerResponse} The clone.
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StartAutoBuyerResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StopAutoBuyerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StopAutoBuyerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StopAutoBuyerRequest.displayName = 'proto.walletrpc.StopAutoBuyerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StopAutoBuyerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StopAutoBuyerRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StopAutoBuyerRequest}
 */
proto.walletrpc.StopAutoBuyerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StopAutoBuyerRequest;
  return proto.walletrpc.StopAutoBuyerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StopAutoBuyerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StopAutoBuyerRequest}
 */
proto.walletrpc.StopAutoBuyerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StopAutoBuyerRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StopAutoBuyerRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StopAutoBuyerRequest} The clone.
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StopAutoBuyerRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StopAutoBuyerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StopAutoBuyerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StopAutoBuyerResponse.displayName = 'proto.walletrpc.StopAutoBuyerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StopAutoBuyerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StopAutoBuyerResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StopAutoBuyerResponse}
 */
proto.walletrpc.StopAutoBuyerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StopAutoBuyerResponse;
  return proto.walletrpc.StopAutoBuyerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StopAutoBuyerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StopAutoBuyerResponse}
 */
proto.walletrpc.StopAutoBuyerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StopAutoBuyerResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StopAutoBuyerResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.StopAutoBuyerResponse} The clone.
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.StopAutoBuyerResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketBuyerConfigRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketBuyerConfigRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketBuyerConfigRequest.displayName = 'proto.walletrpc.TicketBuyerConfigRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketBuyerConfigRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketBuyerConfigRequest}
 */
proto.walletrpc.TicketBuyerConfigRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketBuyerConfigRequest;
  return proto.walletrpc.TicketBuyerConfigRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketBuyerConfigRequest}
 */
proto.walletrpc.TicketBuyerConfigRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketBuyerConfigRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TicketBuyerConfigRequest} The clone.
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TicketBuyerConfigRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketBuyerConfigResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketBuyerConfigResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketBuyerConfigResponse.displayName = 'proto.walletrpc.TicketBuyerConfigResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketBuyerConfigResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount(),
    avgPriceMode: msg.getAvgPriceMode(),
    avgPricevwapDelta: msg.getAvgPricevwapDelta(),
    balanceToMaintain: msg.getBalanceToMaintain(),
    blocksToAvg: msg.getBlocksToAvg(),
    dontWaitForTickets: msg.getDontWaitForTickets(),
    expiryDelta: msg.getExpiryDelta(),
    feeSource: msg.getFeeSource(),
    feeTargetScaling: msg.getFeeTargetScaling(),
    minFee: msg.getMinFee(),
    maxFee: msg.getMaxFee(),
    maxPerBlock: msg.getMaxPerBlock(),
    maxPriceAbsolute: msg.getMaxPriceAbsolute(),
    maxPriceRelative: msg.getMaxPriceRelative(),
    maxInMempool: msg.getMaxInMempool(),
    poolAddress: msg.getPoolAddress(),
    poolFees: msg.getPoolFees(),
    spreadTicketPurchases: msg.getSpreadTicketPurchases(),
    votingAddress: msg.getVotingAddress(),
    txFee: msg.getTxFee()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketBuyerConfigResponse}
 */
proto.walletrpc.TicketBuyerConfigResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketBuyerConfigResponse;
  return proto.walletrpc.TicketBuyerConfigResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketBuyerConfigResponse}
 */
proto.walletrpc.TicketBuyerConfigResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAvgPriceMode(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAvgPricevwapDelta(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBlocksToAvg(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDontWaitForTickets(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpiryDelta(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setFeeSource(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setFeeTargetScaling(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMinFee(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFee(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxInMempool(value);
      break;
    case 18:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 19:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 20:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSpreadTicketPurchases(value);
      break;
    case 21:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    case 22:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTxFee(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketBuyerConfigResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAvgPriceMode();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getAvgPricevwapDelta();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = this.getBlocksToAvg();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getDontWaitForTickets();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getExpiryDelta();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = this.getFeeSource();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = this.getFeeTargetScaling();
  if (f !== 0.0) {
    writer.writeDouble(
      9,
      f
    );
  }
  f = this.getMinFee();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = this.getMaxFee();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = this.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = this.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      14,
      f
    );
  }
  f = this.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      15,
      f
    );
  }
  f = this.getMaxInMempool();
  if (f !== 0) {
    writer.writeInt64(
      17,
      f
    );
  }
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      18,
      f
    );
  }
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      19,
      f
    );
  }
  f = this.getSpreadTicketPurchases();
  if (f) {
    writer.writeBool(
      20,
      f
    );
  }
  f = this.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      21,
      f
    );
  }
  f = this.getTxFee();
  if (f !== 0) {
    writer.writeInt64(
      22,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.TicketBuyerConfigResponse} The clone.
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.TicketBuyerConfigResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string avg_price_mode = 2;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAvgPriceMode = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAvgPriceMode = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 avg_priceVWAP_delta = 3;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAvgPricevwapDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAvgPricevwapDelta = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 balance_to_maintain = 4;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 blocks_to_avg = 5;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getBlocksToAvg = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setBlocksToAvg = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool dont_wait_for_tickets = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getDontWaitForTickets = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 6, false));
};


/** @param {boolean} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setDontWaitForTickets = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 expiry_delta = 7;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getExpiryDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setExpiryDelta = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string fee_source = 8;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getFeeSource = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 8, ""));
};


/** @param {string} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setFeeSource = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional double fee_target_scaling = 9;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getFeeTargetScaling = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 9, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setFeeTargetScaling = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 min_fee = 10;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMinFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 10, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMinFee = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 max_fee = 12;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 12, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxFee = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional int64 max_per_block = 13;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 13, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional int64 max_price_absolute = 14;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 14, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * optional double max_price_relative = 15;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 15, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * optional int64 max_in_mempool = 17;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxInMempool = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 17, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxInMempool = function(value) {
  jspb.Message.setField(this, 17, value);
};


/**
 * optional string pool_address = 18;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 18, ""));
};


/** @param {string} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 18, value);
};


/**
 * optional double pool_fees = 19;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getPoolFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 19, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 19, value);
};


/**
 * optional bool spread_ticket_purchases = 20;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getSpreadTicketPurchases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 20, false));
};


/** @param {boolean} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setSpreadTicketPurchases = function(value) {
  jspb.Message.setField(this, 20, value);
};


/**
 * optional string voting_address = 21;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 21, ""));
};


/** @param {string} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 21, value);
};


/**
 * optional int64 tx_fee = 22;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getTxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 22, 0));
};


/** @param {number} value  */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setTxFee = function(value) {
  jspb.Message.setField(this, 22, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetAccountRequest.displayName = 'proto.walletrpc.SetAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetAccountRequest}
 */
proto.walletrpc.SetAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetAccountRequest;
  return proto.walletrpc.SetAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetAccountRequest}
 */
proto.walletrpc.SetAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetAccountRequest} The clone.
 */
proto.walletrpc.SetAccountRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetAccountRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.SetAccountRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetAccountRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetAccountResponse.displayName = 'proto.walletrpc.SetAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetAccountResponse}
 */
proto.walletrpc.SetAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetAccountResponse;
  return proto.walletrpc.SetAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetAccountResponse}
 */
proto.walletrpc.SetAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetAccountResponse} The clone.
 */
proto.walletrpc.SetAccountResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetAccountResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetBalanceToMaintainRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetBalanceToMaintainRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetBalanceToMaintainRequest.displayName = 'proto.walletrpc.SetBalanceToMaintainRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetBalanceToMaintainRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    balanceToMaintain: msg.getBalanceToMaintain()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetBalanceToMaintainRequest}
 */
proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetBalanceToMaintainRequest;
  return proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetBalanceToMaintainRequest}
 */
proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetBalanceToMaintainRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetBalanceToMaintainRequest} The clone.
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetBalanceToMaintainRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 balance_to_maintain = 1;
 * @return {number}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetBalanceToMaintainResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetBalanceToMaintainResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetBalanceToMaintainResponse.displayName = 'proto.walletrpc.SetBalanceToMaintainResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetBalanceToMaintainResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetBalanceToMaintainResponse}
 */
proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetBalanceToMaintainResponse;
  return proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetBalanceToMaintainResponse}
 */
proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetBalanceToMaintainResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetBalanceToMaintainResponse} The clone.
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetBalanceToMaintainResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxFeeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxFeeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxFeeRequest.displayName = 'proto.walletrpc.SetMaxFeeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxFeeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxFeeRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxFeePerKb: msg.getMaxFeePerKb()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxFeeRequest}
 */
proto.walletrpc.SetMaxFeeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxFeeRequest;
  return proto.walletrpc.SetMaxFeeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxFeeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxFeeRequest}
 */
proto.walletrpc.SetMaxFeeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFeePerKb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxFeeRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxFeeRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxFeeRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMaxFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxFeeRequest} The clone.
 */
proto.walletrpc.SetMaxFeeRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxFeeRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 max_fee_per_kb = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.getMaxFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetMaxFeeRequest.prototype.setMaxFeePerKb = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxFeeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxFeeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxFeeResponse.displayName = 'proto.walletrpc.SetMaxFeeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxFeeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxFeeResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxFeeResponse}
 */
proto.walletrpc.SetMaxFeeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxFeeResponse;
  return proto.walletrpc.SetMaxFeeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxFeeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxFeeResponse}
 */
proto.walletrpc.SetMaxFeeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxFeeResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxFeeResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxFeeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxFeeResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxFeeResponse} The clone.
 */
proto.walletrpc.SetMaxFeeResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxFeeResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceRelativeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceRelativeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceRelativeRequest.displayName = 'proto.walletrpc.SetMaxPriceRelativeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceRelativeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPriceRelative: msg.getMaxPriceRelative()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceRelativeRequest}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceRelativeRequest;
  return proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceRelativeRequest}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceRelativeRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPriceRelativeRequest} The clone.
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPriceRelativeRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional double max_price_relative = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceRelativeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceRelativeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceRelativeResponse.displayName = 'proto.walletrpc.SetMaxPriceRelativeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceRelativeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceRelativeResponse}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceRelativeResponse;
  return proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceRelativeResponse}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceRelativeResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPriceRelativeResponse} The clone.
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPriceRelativeResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceAbsoluteRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceAbsoluteRequest.displayName = 'proto.walletrpc.SetMaxPriceAbsoluteRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceAbsoluteRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPriceAbsolute: msg.getMaxPriceAbsolute()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteRequest}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceAbsoluteRequest;
  return proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteRequest}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteRequest} The clone.
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPriceAbsoluteRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 max_price_absolute = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceAbsoluteResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceAbsoluteResponse.displayName = 'proto.walletrpc.SetMaxPriceAbsoluteResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceAbsoluteResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteResponse}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceAbsoluteResponse;
  return proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteResponse}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteResponse} The clone.
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPriceAbsoluteResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVotingAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVotingAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVotingAddressRequest.displayName = 'proto.walletrpc.SetVotingAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVotingAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVotingAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    votingAddress: msg.getVotingAddress()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVotingAddressRequest}
 */
proto.walletrpc.SetVotingAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVotingAddressRequest;
  return proto.walletrpc.SetVotingAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVotingAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVotingAddressRequest}
 */
proto.walletrpc.SetVotingAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVotingAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVotingAddressRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVotingAddressRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetVotingAddressRequest} The clone.
 */
proto.walletrpc.SetVotingAddressRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetVotingAddressRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string voting_address = 1;
 * @return {string}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SetVotingAddressRequest.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVotingAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVotingAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVotingAddressResponse.displayName = 'proto.walletrpc.SetVotingAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVotingAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVotingAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVotingAddressResponse}
 */
proto.walletrpc.SetVotingAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVotingAddressResponse;
  return proto.walletrpc.SetVotingAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVotingAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVotingAddressResponse}
 */
proto.walletrpc.SetVotingAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVotingAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVotingAddressResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVotingAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVotingAddressResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetVotingAddressResponse} The clone.
 */
proto.walletrpc.SetVotingAddressResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetVotingAddressResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolAddressRequest.displayName = 'proto.walletrpc.SetPoolAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolAddress: msg.getPoolAddress()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolAddressRequest}
 */
proto.walletrpc.SetPoolAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolAddressRequest;
  return proto.walletrpc.SetPoolAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolAddressRequest}
 */
proto.walletrpc.SetPoolAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolAddressRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolAddressRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetPoolAddressRequest} The clone.
 */
proto.walletrpc.SetPoolAddressRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetPoolAddressRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string pool_address = 1;
 * @return {string}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SetPoolAddressRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolAddressResponse.displayName = 'proto.walletrpc.SetPoolAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolAddressResponse}
 */
proto.walletrpc.SetPoolAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolAddressResponse;
  return proto.walletrpc.SetPoolAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolAddressResponse}
 */
proto.walletrpc.SetPoolAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolAddressResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolAddressResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetPoolAddressResponse} The clone.
 */
proto.walletrpc.SetPoolAddressResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetPoolAddressResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolFeesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolFeesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolFeesRequest.displayName = 'proto.walletrpc.SetPoolFeesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolFeesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolFeesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolFees: msg.getPoolFees()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolFeesRequest}
 */
proto.walletrpc.SetPoolFeesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolFeesRequest;
  return proto.walletrpc.SetPoolFeesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolFeesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolFeesRequest}
 */
proto.walletrpc.SetPoolFeesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolFeesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolFeesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolFeesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetPoolFeesRequest} The clone.
 */
proto.walletrpc.SetPoolFeesRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetPoolFeesRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional double pool_fees = 1;
 * @return {number}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetPoolFeesRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolFeesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolFeesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolFeesResponse.displayName = 'proto.walletrpc.SetPoolFeesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolFeesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolFeesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolFeesResponse}
 */
proto.walletrpc.SetPoolFeesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolFeesResponse;
  return proto.walletrpc.SetPoolFeesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolFeesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolFeesResponse}
 */
proto.walletrpc.SetPoolFeesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolFeesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolFeesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolFeesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetPoolFeesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetPoolFeesResponse} The clone.
 */
proto.walletrpc.SetPoolFeesResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetPoolFeesResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPerBlockRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPerBlockRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPerBlockRequest.displayName = 'proto.walletrpc.SetMaxPerBlockRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPerBlockRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPerBlock: msg.getMaxPerBlock()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPerBlockRequest}
 */
proto.walletrpc.SetMaxPerBlockRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPerBlockRequest;
  return proto.walletrpc.SetMaxPerBlockRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPerBlockRequest}
 */
proto.walletrpc.SetMaxPerBlockRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPerBlockRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPerBlockRequest} The clone.
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPerBlockRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 max_per_block = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetMaxPerBlockRequest.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPerBlockResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPerBlockResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPerBlockResponse.displayName = 'proto.walletrpc.SetMaxPerBlockResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPerBlockResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPerBlockResponse}
 */
proto.walletrpc.SetMaxPerBlockResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPerBlockResponse;
  return proto.walletrpc.SetMaxPerBlockResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPerBlockResponse}
 */
proto.walletrpc.SetMaxPerBlockResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPerBlockResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetMaxPerBlockResponse} The clone.
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetMaxPerBlockResponse} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AgendasRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasRequest.displayName = 'proto.walletrpc.AgendasRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AgendasRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasRequest}
 */
proto.walletrpc.AgendasRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasRequest;
  return proto.walletrpc.AgendasRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasRequest}
 */
proto.walletrpc.AgendasRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AgendasRequest} The clone.
 */
proto.walletrpc.AgendasRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AgendasRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AgendasResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AgendasResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.displayName = 'proto.walletrpc.AgendasResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AgendasResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: msg.getVersion(),
    agendasList: jspb.Message.toObjectList(msg.getAgendasList(),
    proto.walletrpc.AgendasResponse.Agenda.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse}
 */
proto.walletrpc.AgendasResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse;
  return proto.walletrpc.AgendasResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse}
 */
proto.walletrpc.AgendasResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = new proto.walletrpc.AgendasResponse.Agenda;
      reader.readMessage(value,proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader);
      msg.getAgendasList().push(value);
      msg.setAgendasList(msg.getAgendasList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAgendasList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.AgendasResponse.Agenda.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AgendasResponse} The clone.
 */
proto.walletrpc.AgendasResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AgendasResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.AgendasResponse.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated Agenda agendas = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.AgendasResponse.Agenda>}
 */
proto.walletrpc.AgendasResponse.prototype.getAgendasList = function() {
  return /** @type{!Array.<!proto.walletrpc.AgendasResponse.Agenda>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AgendasResponse.Agenda, 2));
};


/** @param {Array.<!proto.walletrpc.AgendasResponse.Agenda>} value  */
proto.walletrpc.AgendasResponse.prototype.setAgendasList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


proto.walletrpc.AgendasResponse.prototype.clearAgendasList = function() {
  this.setAgendasList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse.Agenda = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AgendasResponse.Agenda.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AgendasResponse.Agenda, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.Agenda.displayName = 'proto.walletrpc.AgendasResponse.Agenda';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AgendasResponse.Agenda.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.Agenda.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse.Agenda} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Agenda.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.getId(),
    description: msg.getDescription(),
    mask: msg.getMask(),
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.AgendasResponse.Choice.toObject, includeInstance),
    startTime: msg.getStartTime(),
    expireTime: msg.getExpireTime()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse.Agenda}
 */
proto.walletrpc.AgendasResponse.Agenda.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse.Agenda;
  return proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse.Agenda} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse.Agenda}
 */
proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMask(value);
      break;
    case 4:
      var value = new proto.walletrpc.AgendasResponse.Choice;
      reader.readMessage(value,proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader);
      msg.getChoicesList().push(value);
      msg.setChoicesList(msg.getChoicesList());
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setStartTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpireTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse.Agenda} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.Agenda.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getMask();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.AgendasResponse.Choice.serializeBinaryToWriter
    );
  }
  f = this.getStartTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getExpireTime();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AgendasResponse.Agenda} The clone.
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AgendasResponse.Agenda} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string description = 2;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 mask = 3;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getMask = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setMask = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated Choice choices = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.AgendasResponse.Choice>}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.AgendasResponse.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AgendasResponse.Choice, 4));
};


/** @param {Array.<!proto.walletrpc.AgendasResponse.Choice>} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


proto.walletrpc.AgendasResponse.Agenda.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};


/**
 * optional int64 start_time = 5;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getStartTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setStartTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 expire_time = 6;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getExpireTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.AgendasResponse.Agenda.prototype.setExpireTime = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AgendasResponse.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.Choice.displayName = 'proto.walletrpc.AgendasResponse.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse.Choice} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.getId(),
    description: msg.getDescription(),
    bits: msg.getBits(),
    isAbstain: msg.getIsAbstain(),
    isNo: msg.getIsNo()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse.Choice}
 */
proto.walletrpc.AgendasResponse.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse.Choice;
  return proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse.Choice}
 */
proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBits(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsAbstain(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsNo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse.Choice} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.Choice.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AgendasResponse.Choice.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getBits();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getIsAbstain();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = this.getIsNo();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.AgendasResponse.Choice} The clone.
 */
proto.walletrpc.AgendasResponse.Choice.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.AgendasResponse.Choice} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.AgendasResponse.Choice.prototype.setId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string description = 2;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.AgendasResponse.Choice.prototype.setDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 bits = 3;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getBits = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.AgendasResponse.Choice.prototype.setBits = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool is_abstain = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getIsAbstain = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 4, false));
};


/** @param {boolean} value  */
proto.walletrpc.AgendasResponse.Choice.prototype.setIsAbstain = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool is_no = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getIsNo = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 5, false));
};


/** @param {boolean} value  */
proto.walletrpc.AgendasResponse.Choice.prototype.setIsNo = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VoteChoicesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesRequest.displayName = 'proto.walletrpc.VoteChoicesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesRequest}
 */
proto.walletrpc.VoteChoicesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesRequest;
  return proto.walletrpc.VoteChoicesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesRequest}
 */
proto.walletrpc.VoteChoicesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VoteChoicesRequest} The clone.
 */
proto.walletrpc.VoteChoicesRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VoteChoicesRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.VoteChoicesResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.VoteChoicesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesResponse.displayName = 'proto.walletrpc.VoteChoicesResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.VoteChoicesResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: msg.getVersion(),
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.VoteChoicesResponse.Choice.toObject, includeInstance),
    votebits: msg.getVotebits()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesResponse}
 */
proto.walletrpc.VoteChoicesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesResponse;
  return proto.walletrpc.VoteChoicesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesResponse}
 */
proto.walletrpc.VoteChoicesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = new proto.walletrpc.VoteChoicesResponse.Choice;
      reader.readMessage(value,proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader);
      msg.getChoicesList().push(value);
      msg.setChoicesList(msg.getChoicesList());
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVotebits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.VoteChoicesResponse.Choice.serializeBinaryToWriter
    );
  }
  f = this.getVotebits();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VoteChoicesResponse} The clone.
 */
proto.walletrpc.VoteChoicesResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VoteChoicesResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.VoteChoicesResponse.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated Choice choices = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.VoteChoicesResponse.Choice>}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.VoteChoicesResponse.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.VoteChoicesResponse.Choice, 2));
};


/** @param {Array.<!proto.walletrpc.VoteChoicesResponse.Choice>} value  */
proto.walletrpc.VoteChoicesResponse.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


proto.walletrpc.VoteChoicesResponse.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};


/**
 * optional uint32 votebits = 3;
 * @return {number}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getVotebits = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.VoteChoicesResponse.prototype.setVotebits = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesResponse.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VoteChoicesResponse.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesResponse.Choice.displayName = 'proto.walletrpc.VoteChoicesResponse.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesResponse.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    agendaId: msg.getAgendaId(),
    agendaDescription: msg.getAgendaDescription(),
    choiceId: msg.getChoiceId(),
    choiceDescription: msg.getChoiceDescription()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice}
 */
proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesResponse.Choice;
  return proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice}
 */
proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaDescription(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceId(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceDescription(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesResponse.Choice.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAgendaId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getAgendaDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getChoiceId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = this.getChoiceDescription();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice} The clone.
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VoteChoicesResponse.Choice} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string agenda_id = 1;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getAgendaId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setAgendaId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string agenda_description = 2;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getAgendaDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setAgendaDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string choice_id = 3;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getChoiceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/** @param {string} value  */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setChoiceId = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string choice_description = 4;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getChoiceDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/** @param {string} value  */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setChoiceDescription = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SetVoteChoicesRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesRequest.displayName = 'proto.walletrpc.SetVoteChoicesRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SetVoteChoicesRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.SetVoteChoicesRequest.Choice.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesRequest}
 */
proto.walletrpc.SetVoteChoicesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesRequest;
  return proto.walletrpc.SetVoteChoicesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesRequest}
 */
proto.walletrpc.SetVoteChoicesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.SetVoteChoicesRequest.Choice;
      reader.readMessage(value,proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader);
      msg.getChoicesList().push(value);
      msg.setChoicesList(msg.getChoicesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.SetVoteChoicesRequest.Choice.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetVoteChoicesRequest} The clone.
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetVoteChoicesRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated Choice choices = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SetVoteChoicesRequest.Choice, 1));
};


/** @param {Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>} value  */
proto.walletrpc.SetVoteChoicesRequest.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.SetVoteChoicesRequest.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesRequest.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesRequest.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesRequest.Choice.displayName = 'proto.walletrpc.SetVoteChoicesRequest.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesRequest.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    agendaId: msg.getAgendaId(),
    choiceId: msg.getChoiceId()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesRequest.Choice;
  return proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAgendaId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getChoiceId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice} The clone.
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetVoteChoicesRequest.Choice} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string agenda_id = 1;
 * @return {string}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.getAgendaId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.setAgendaId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string choice_id = 2;
 * @return {string}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.getChoiceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.setChoiceId = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesResponse.displayName = 'proto.walletrpc.SetVoteChoicesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    votebits: msg.getVotebits()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesResponse}
 */
proto.walletrpc.SetVoteChoicesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesResponse;
  return proto.walletrpc.SetVoteChoicesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesResponse}
 */
proto.walletrpc.SetVoteChoicesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVotebits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVotebits();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SetVoteChoicesResponse} The clone.
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SetVoteChoicesResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 votebits = 1;
 * @return {number}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.getVotebits = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.SetVoteChoicesResponse.prototype.setVotebits = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VerifyMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VerifyMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VerifyMessageRequest.displayName = 'proto.walletrpc.VerifyMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VerifyMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VerifyMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress(),
    message: msg.getMessage(),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VerifyMessageRequest}
 */
proto.walletrpc.VerifyMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VerifyMessageRequest;
  return proto.walletrpc.VerifyMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VerifyMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VerifyMessageRequest}
 */
proto.walletrpc.VerifyMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VerifyMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VerifyMessageRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VerifyMessageRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VerifyMessageRequest} The clone.
 */
proto.walletrpc.VerifyMessageRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VerifyMessageRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.VerifyMessageRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.VerifyMessageRequest.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes signature = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 3, ""));
};


/**
 * optional bytes signature = 3;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.VerifyMessageRequest.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VerifyMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VerifyMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VerifyMessageResponse.displayName = 'proto.walletrpc.VerifyMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VerifyMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VerifyMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    valid: msg.getValid()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VerifyMessageResponse}
 */
proto.walletrpc.VerifyMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VerifyMessageResponse;
  return proto.walletrpc.VerifyMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VerifyMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VerifyMessageResponse}
 */
proto.walletrpc.VerifyMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VerifyMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VerifyMessageResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VerifyMessageResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.VerifyMessageResponse} The clone.
 */
proto.walletrpc.VerifyMessageResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.VerifyMessageResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool valid = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.VerifyMessageResponse.prototype.getValid = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.VerifyMessageResponse.prototype.setValid = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.DecodedTransaction.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.displayName = 'proto.walletrpc.DecodedTransaction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.DecodedTransaction.repeatedFields_ = [6,7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    version: msg.getVersion(),
    lockTime: msg.getLockTime(),
    expiry: msg.getExpiry(),
    transactionType: msg.getTransactionType(),
    inputsList: jspb.Message.toObjectList(msg.getInputsList(),
    proto.walletrpc.DecodedTransaction.Input.toObject, includeInstance),
    outputsList: jspb.Message.toObjectList(msg.getOutputsList(),
    proto.walletrpc.DecodedTransaction.Output.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodedTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction;
  return proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLockTime(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 5:
      var value = /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (reader.readEnum());
      msg.setTransactionType(value);
      break;
    case 6:
      var value = new proto.walletrpc.DecodedTransaction.Input;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader);
      msg.getInputsList().push(value);
      msg.setInputsList(msg.getInputsList());
      break;
    case 7:
      var value = new proto.walletrpc.DecodedTransaction.Output;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader);
      msg.getOutputsList().push(value);
      msg.setOutputsList(msg.getOutputsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getVersion();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getLockTime();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getTransactionType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = this.getInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.walletrpc.DecodedTransaction.Input.serializeBinaryToWriter
    );
  }
  f = this.getOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.walletrpc.DecodedTransaction.Output.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodedTransaction} The clone.
 */
proto.walletrpc.DecodedTransaction.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodedTransaction.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 version = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 lock_time = 3;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getLockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.prototype.setLockTime = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 expiry = 4;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional TransactionDetails.TransactionType transaction_type = 5;
 * @return {!proto.walletrpc.TransactionDetails.TransactionType}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionType = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {!proto.walletrpc.TransactionDetails.TransactionType} value  */
proto.walletrpc.DecodedTransaction.prototype.setTransactionType = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * repeated Input inputs = 6;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.DecodedTransaction.Input>}
 */
proto.walletrpc.DecodedTransaction.prototype.getInputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.DecodedTransaction.Input>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.DecodedTransaction.Input, 6));
};


/** @param {Array.<!proto.walletrpc.DecodedTransaction.Input>} value  */
proto.walletrpc.DecodedTransaction.prototype.setInputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};


proto.walletrpc.DecodedTransaction.prototype.clearInputsList = function() {
  this.setInputsList([]);
};


/**
 * repeated Output outputs = 7;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.DecodedTransaction.Output>}
 */
proto.walletrpc.DecodedTransaction.prototype.getOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.DecodedTransaction.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.DecodedTransaction.Output, 7));
};


/** @param {Array.<!proto.walletrpc.DecodedTransaction.Output>} value  */
proto.walletrpc.DecodedTransaction.prototype.setOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 7, value);
};


proto.walletrpc.DecodedTransaction.prototype.clearOutputsList = function() {
  this.setOutputsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.Input.displayName = 'proto.walletrpc.DecodedTransaction.Input';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction.Input} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    previousTransactionHash: msg.getPreviousTransactionHash_asB64(),
    previousTransactionIndex: msg.getPreviousTransactionIndex(),
    tree: msg.getTree(),
    sequence: msg.getSequence(),
    amountIn: msg.getAmountIn(),
    blockHeight: msg.getBlockHeight(),
    blockIndex: msg.getBlockIndex(),
    signatureScript: msg.getSignatureScript_asB64(),
    signatureScriptAsm: msg.getSignatureScriptAsm()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction.Input}
 */
proto.walletrpc.DecodedTransaction.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction.Input;
  return proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction.Input}
 */
proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreviousTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPreviousTransactionIndex(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.DecodedTransaction.Input.TreeType} */ (reader.readEnum());
      msg.setTree(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSequence(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmountIn(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBlockHeight(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBlockIndex(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureScript(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignatureScriptAsm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction.Input} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.Input.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.Input.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPreviousTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getPreviousTransactionIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getTree();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = this.getSequence();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getAmountIn();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getBlockHeight();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = this.getBlockIndex();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = this.getSignatureScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = this.getSignatureScriptAsm();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodedTransaction.Input} The clone.
 */
proto.walletrpc.DecodedTransaction.Input.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Input} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes previous_transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes previous_transaction_hash = 1;
 * This is a type-conversion wrapper around `getPreviousTransactionHash()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreviousTransactionHash()));
};


/**
 * optional bytes previous_transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreviousTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreviousTransactionHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setPreviousTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 previous_transaction_index = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setPreviousTransactionIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional TreeType tree = 3;
 * @return {!proto.walletrpc.DecodedTransaction.Input.TreeType}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getTree = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Input.TreeType} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {!proto.walletrpc.DecodedTransaction.Input.TreeType} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setTree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 sequence = 4;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSequence = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setSequence = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 amount_in = 5;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getAmountIn = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 5, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setAmountIn = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 block_height = 6;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 block_index = 7;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getBlockIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setBlockIndex = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional bytes signature_script = 8;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 8, ""));
};


/**
 * optional bytes signature_script = 8;
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureScript()));
};


/**
 * optional bytes signature_script = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setSignatureScript = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional string signature_script_asm = 9;
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScriptAsm = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 9, ""));
};


/** @param {string} value  */
proto.walletrpc.DecodedTransaction.Input.prototype.setSignatureScriptAsm = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.DecodedTransaction.Input.TreeType = {
  REGULAR: 0,
  UNKNOWN: -1,
  STAKE: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.DecodedTransaction.Output.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.Output.displayName = 'proto.walletrpc.DecodedTransaction.Output';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.DecodedTransaction.Output.repeatedFields_ = [8];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction.Output} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue(),
    index: msg.getIndex(),
    version: msg.getVersion(),
    script: msg.getScript_asB64(),
    scriptAsm: msg.getScriptAsm(),
    requiredSignatures: msg.getRequiredSignatures(),
    scriptClass: msg.getScriptClass(),
    addressesList: jspb.Message.getField(msg, 8),
    commitmentAmount: msg.getCommitmentAmount()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction.Output}
 */
proto.walletrpc.DecodedTransaction.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction.Output;
  return proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction.Output}
 */
proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setVersion(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setScriptAsm(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredSignatures(value);
      break;
    case 7:
      var value = /** @type {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} */ (reader.readEnum());
      msg.setScriptClass(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.getAddressesList().push(value);
      msg.setAddressesList(msg.getAddressesList());
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitmentAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction.Output} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.Output.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodedTransaction.Output.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getValue();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getVersion();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getScriptAsm();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getRequiredSignatures();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = this.getScriptClass();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = this.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      8,
      f
    );
  }
  f = this.getCommitmentAmount();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodedTransaction.Output} The clone.
 */
proto.walletrpc.DecodedTransaction.Output.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Output} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional int64 value = 1;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setValue = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 index = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 version = 3;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/**
 * optional bytes script = 4;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string script_asm = 5;
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScriptAsm = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/** @param {string} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setScriptAsm = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int32 required_signatures = 6;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getRequiredSignatures = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 6, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setRequiredSignatures = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional ScriptClass script_class = 7;
 * @return {!proto.walletrpc.DecodedTransaction.Output.ScriptClass}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScriptClass = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} */ (jspb.Message.getFieldProto3(this, 7, 0));
};


/** @param {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setScriptClass = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * repeated string addresses = 8;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getAddressesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getField(this, 8));
};


/** @param {Array.<string>} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setAddressesList = function(value) {
  jspb.Message.setField(this, 8, value || []);
};


proto.walletrpc.DecodedTransaction.Output.prototype.clearAddressesList = function() {
  jspb.Message.setField(this, 8, []);
};


/**
 * optional int64 commitment_amount = 9;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getCommitmentAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 9, 0));
};


/** @param {number} value  */
proto.walletrpc.DecodedTransaction.Output.prototype.setCommitmentAmount = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.DecodedTransaction.Output.ScriptClass = {
  NON_STANDARD: 0,
  PUB_KEY: 1,
  PUB_KEY_HASH: 2,
  SCRIPT_HASH: 3,
  MULTI_SIG: 4,
  NULL_DATA: 5,
  STAKE_SUBMISSION: 6,
  STAKE_GEN: 7,
  STAKE_REVOCATION: 8,
  STAKE_SUB_CHANGE: 9,
  PUB_KEY_ALT: 10,
  PUB_KEY_HASH_ALT: 11
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeRawTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeRawTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeRawTransactionRequest.displayName = 'proto.walletrpc.DecodeRawTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeRawTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    serializedTransaction: msg.getSerializedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeRawTransactionRequest}
 */
proto.walletrpc.DecodeRawTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeRawTransactionRequest;
  return proto.walletrpc.DecodeRawTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeRawTransactionRequest}
 */
proto.walletrpc.DecodeRawTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeRawTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodeRawTransactionRequest} The clone.
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodeRawTransactionRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes serialized_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes serialized_transaction = 1;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.DecodeRawTransactionRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeRawTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeRawTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeRawTransactionResponse.displayName = 'proto.walletrpc.DecodeRawTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeRawTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: (f = msg.getTransaction()) && proto.walletrpc.DecodedTransaction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeRawTransactionResponse}
 */
proto.walletrpc.DecodeRawTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeRawTransactionResponse;
  return proto.walletrpc.DecodeRawTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeRawTransactionResponse}
 */
proto.walletrpc.DecodeRawTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.DecodedTransaction;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader);
      msg.setTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeRawTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransaction();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.DecodedTransaction.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.DecodeRawTransactionResponse} The clone.
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.DecodeRawTransactionResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional DecodedTransaction transaction = 1;
 * @return {proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.getTransaction = function() {
  return /** @type{proto.walletrpc.DecodedTransaction} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.DecodedTransaction, 1));
};


/** @param {proto.walletrpc.DecodedTransaction|undefined} value  */
proto.walletrpc.DecodeRawTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.DecodeRawTransactionResponse.prototype.clearTransaction = function() {
  this.setTransaction(undefined);
};


/**
 * Returns whether this field is set.
 * @return{!boolean}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.hasTransaction = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ValidateAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ValidateAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ValidateAddressRequest.displayName = 'proto.walletrpc.ValidateAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ValidateAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ValidateAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ValidateAddressRequest}
 */
proto.walletrpc.ValidateAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ValidateAddressRequest;
  return proto.walletrpc.ValidateAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ValidateAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ValidateAddressRequest}
 */
proto.walletrpc.ValidateAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ValidateAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ValidateAddressRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ValidateAddressRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ValidateAddressRequest} The clone.
 */
proto.walletrpc.ValidateAddressRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ValidateAddressRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.ValidateAddressRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.ValidateAddressRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ValidateAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ValidateAddressResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ValidateAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ValidateAddressResponse.displayName = 'proto.walletrpc.ValidateAddressResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ValidateAddressResponse.repeatedFields_ = [7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ValidateAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ValidateAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    isValid: msg.getIsValid(),
    isMine: msg.getIsMine(),
    accountNumber: msg.getAccountNumber(),
    pubKeyAddr: msg.getPubKeyAddr(),
    pubKey: msg.getPubKey_asB64(),
    isScript: msg.getIsScript(),
    pkScriptAddrsList: jspb.Message.getField(msg, 7),
    scriptType: msg.getScriptType(),
    payToAddrScript: msg.getPayToAddrScript_asB64(),
    sigsRequired: msg.getSigsRequired(),
    isInternal: msg.getIsInternal(),
    index: msg.getIndex()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ValidateAddressResponse}
 */
proto.walletrpc.ValidateAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ValidateAddressResponse;
  return proto.walletrpc.ValidateAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ValidateAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ValidateAddressResponse}
 */
proto.walletrpc.ValidateAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsValid(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsMine(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKeyAddr(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubKey(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsScript(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.getPkScriptAddrsList().push(value);
      msg.setPkScriptAddrsList(msg.getPkScriptAddrsList());
      break;
    case 8:
      var value = /** @type {!proto.walletrpc.ValidateAddressResponse.ScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    case 9:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayToAddrScript(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSigsRequired(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsInternal(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ValidateAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ValidateAddressResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ValidateAddressResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getIsValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getIsMine();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getPubKeyAddr();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = this.getPubKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = this.getIsScript();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getPkScriptAddrsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      7,
      f
    );
  }
  f = this.getScriptType();
  if (f !== 0.0) {
    writer.writeEnum(
      8,
      f
    );
  }
  f = this.getPayToAddrScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      9,
      f
    );
  }
  f = this.getSigsRequired();
  if (f !== 0) {
    writer.writeUint32(
      10,
      f
    );
  }
  f = this.getIsInternal();
  if (f) {
    writer.writeBool(
      11,
      f
    );
  }
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      12,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.ValidateAddressResponse} The clone.
 */
proto.walletrpc.ValidateAddressResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.ValidateAddressResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bool is_valid = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsValid = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 1, false));
};


/** @param {boolean} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setIsValid = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool is_mine = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsMine = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 2, false));
};


/** @param {boolean} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setIsMine = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 account_number = 3;
 * @return {number}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string pub_key_addr = 4;
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKeyAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 4, ""));
};


/** @param {string} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setPubKeyAddr = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes pub_key = 5;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 5, ""));
};


/**
 * optional bytes pub_key = 5;
 * This is a type-conversion wrapper around `getPubKey()`
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubKey()));
};


/**
 * optional bytes pub_key = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubKey()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubKey()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool is_script = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsScript = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 6, false));
};


/** @param {boolean} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setIsScript = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * repeated string pk_script_addrs = 7;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<string>}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPkScriptAddrsList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getField(this, 7));
};


/** @param {Array.<string>} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setPkScriptAddrsList = function(value) {
  jspb.Message.setField(this, 7, value || []);
};


proto.walletrpc.ValidateAddressResponse.prototype.clearPkScriptAddrsList = function() {
  jspb.Message.setField(this, 7, []);
};


/**
 * optional ScriptType script_type = 8;
 * @return {!proto.walletrpc.ValidateAddressResponse.ScriptType}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getScriptType = function() {
  return /** @type {!proto.walletrpc.ValidateAddressResponse.ScriptType} */ (jspb.Message.getFieldProto3(this, 8, 0));
};


/** @param {!proto.walletrpc.ValidateAddressResponse.ScriptType} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional bytes pay_to_addr_script = 9;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 9, ""));
};


/**
 * optional bytes pay_to_addr_script = 9;
 * This is a type-conversion wrapper around `getPayToAddrScript()`
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayToAddrScript()));
};


/**
 * optional bytes pay_to_addr_script = 9;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayToAddrScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayToAddrScript()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setPayToAddrScript = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional uint32 sigs_required = 10;
 * @return {number}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getSigsRequired = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 10, 0));
};


/** @param {number} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setSigsRequired = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional bool is_internal = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsInternal = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldProto3(this, 11, false));
};


/** @param {boolean} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setIsInternal = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional uint32 index = 12;
 * @return {number}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 12, 0));
};


/** @param {number} value  */
proto.walletrpc.ValidateAddressResponse.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.ValidateAddressResponse.ScriptType = {
  NONSTANDARDTY: 0,
  PUBKEYTY: 1,
  PUBKEYHASHTY: 2,
  SCRIPTHASHTY: 3,
  MULTISIGTY: 4,
  NULLDATATY: 5,
  STAKESUBMISSIONTY: 6,
  STAKEGENTY: 7,
  STAKEREVOCATIONTY: 8,
  STAKESUBCHANGETY: 9,
  PUBKEYALTTY: 10,
  PUBKEYHASHALTTY: 11
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CommittedTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.CommittedTicketsRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.CommittedTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CommittedTicketsRequest.displayName = 'proto.walletrpc.CommittedTicketsRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.CommittedTicketsRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CommittedTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CommittedTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketsList: msg.getTicketsList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CommittedTicketsRequest}
 */
proto.walletrpc.CommittedTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CommittedTicketsRequest;
  return proto.walletrpc.CommittedTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CommittedTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CommittedTicketsRequest}
 */
proto.walletrpc.CommittedTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.getTicketsList().push(value);
      msg.setTicketsList(msg.getTicketsList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CommittedTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CommittedTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketsList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CommittedTicketsRequest} The clone.
 */
proto.walletrpc.CommittedTicketsRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CommittedTicketsRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated bytes tickets = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.CommittedTicketsRequest.prototype.getTicketsList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 1));
};


/**
 * repeated bytes tickets = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getTicketsList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.CommittedTicketsRequest.prototype.getTicketsList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTicketsList()));
};


/**
 * repeated bytes tickets = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicketsList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.CommittedTicketsRequest.prototype.getTicketsList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTicketsList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value  */
proto.walletrpc.CommittedTicketsRequest.prototype.setTicketsList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


proto.walletrpc.CommittedTicketsRequest.prototype.clearTicketsList = function() {
  jspb.Message.setField(this, 1, []);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetAccountExtendedPubKeyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetAccountExtendedPubKeyRequest.displayName = 'proto.walletrpc.GetAccountExtendedPubKeyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetAccountExtendedPubKeyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyRequest}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetAccountExtendedPubKeyRequest;
  return proto.walletrpc.GetAccountExtendedPubKeyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyRequest}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyRequest} The clone.
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetAccountExtendedPubKeyRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.GetAccountExtendedPubKeyRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetAccountExtendedPubKeyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetAccountExtendedPubKeyResponse.displayName = 'proto.walletrpc.GetAccountExtendedPubKeyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetAccountExtendedPubKeyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accExtendedPubKey: msg.getAccExtendedPubKey()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyResponse}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetAccountExtendedPubKeyResponse;
  return proto.walletrpc.GetAccountExtendedPubKeyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyResponse}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccExtendedPubKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetAccountExtendedPubKeyResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccExtendedPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetAccountExtendedPubKeyResponse} The clone.
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetAccountExtendedPubKeyResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string acc_extended_pub_key = 1;
 * @return {string}
 */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.getAccExtendedPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.GetAccountExtendedPubKeyResponse.prototype.setAccExtendedPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetAccountExtendedPrivKeyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetAccountExtendedPrivKeyRequest.displayName = 'proto.walletrpc.GetAccountExtendedPrivKeyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetAccountExtendedPrivKeyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: msg.getAccountNumber(),
    passphrase: msg.getPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyRequest}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetAccountExtendedPrivKeyRequest;
  return proto.walletrpc.GetAccountExtendedPrivKeyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyRequest}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyRequest} The clone.
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetAccountExtendedPrivKeyRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes passphrase = 2;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.GetAccountExtendedPrivKeyRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetAccountExtendedPrivKeyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetAccountExtendedPrivKeyResponse.displayName = 'proto.walletrpc.GetAccountExtendedPrivKeyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetAccountExtendedPrivKeyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accExtendedPrivKey: msg.getAccExtendedPrivKey()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyResponse}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetAccountExtendedPrivKeyResponse;
  return proto.walletrpc.GetAccountExtendedPrivKeyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyResponse}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccExtendedPrivKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetAccountExtendedPrivKeyResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccExtendedPrivKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.GetAccountExtendedPrivKeyResponse} The clone.
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.GetAccountExtendedPrivKeyResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string acc_extended_priv_key = 1;
 * @return {string}
 */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.getAccExtendedPrivKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.GetAccountExtendedPrivKeyResponse.prototype.setAccExtendedPrivKey = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CommittedTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.CommittedTicketsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.CommittedTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CommittedTicketsResponse.displayName = 'proto.walletrpc.CommittedTicketsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.CommittedTicketsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CommittedTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CommittedTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketaddressesList: jspb.Message.toObjectList(msg.getTicketaddressesList(),
    proto.walletrpc.CommittedTicketsResponse.TicketAddress.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CommittedTicketsResponse}
 */
proto.walletrpc.CommittedTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CommittedTicketsResponse;
  return proto.walletrpc.CommittedTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CommittedTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CommittedTicketsResponse}
 */
proto.walletrpc.CommittedTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.CommittedTicketsResponse.TicketAddress;
      reader.readMessage(value,proto.walletrpc.CommittedTicketsResponse.TicketAddress.deserializeBinaryFromReader);
      msg.getTicketaddressesList().push(value);
      msg.setTicketaddressesList(msg.getTicketaddressesList());
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CommittedTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CommittedTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketaddressesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.CommittedTicketsResponse.TicketAddress.serializeBinaryToWriter
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CommittedTicketsResponse} The clone.
 */
proto.walletrpc.CommittedTicketsResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CommittedTicketsResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * repeated TicketAddress ticketAddresses = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.CommittedTicketsResponse.TicketAddress>}
 */
proto.walletrpc.CommittedTicketsResponse.prototype.getTicketaddressesList = function() {
  return /** @type{!Array.<!proto.walletrpc.CommittedTicketsResponse.TicketAddress>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.CommittedTicketsResponse.TicketAddress, 1));
};


/** @param {Array.<!proto.walletrpc.CommittedTicketsResponse.TicketAddress>} value  */
proto.walletrpc.CommittedTicketsResponse.prototype.setTicketaddressesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


proto.walletrpc.CommittedTicketsResponse.prototype.clearTicketaddressesList = function() {
  this.setTicketaddressesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CommittedTicketsResponse.TicketAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CommittedTicketsResponse.TicketAddress.displayName = 'proto.walletrpc.CommittedTicketsResponse.TicketAddress';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CommittedTicketsResponse.TicketAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CommittedTicketsResponse.TicketAddress} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticket: msg.getTicket_asB64(),
    address: msg.getAddress()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CommittedTicketsResponse.TicketAddress}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CommittedTicketsResponse.TicketAddress;
  return proto.walletrpc.CommittedTicketsResponse.TicketAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CommittedTicketsResponse.TicketAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CommittedTicketsResponse.TicketAddress}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTicket(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CommittedTicketsResponse.TicketAddress} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicket_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.CommittedTicketsResponse.TicketAddress} The clone.
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.CommittedTicketsResponse.TicketAddress} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes ticket = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.getTicket = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes ticket = 1;
 * This is a type-conversion wrapper around `getTicket()`
 * @return {string}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.getTicket_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTicket()));
};


/**
 * optional bytes ticket = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicket()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.getTicket_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTicket()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.setTicket = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.CommittedTicketsResponse.TicketAddress.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BestBlockRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BestBlockRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BestBlockRequest.displayName = 'proto.walletrpc.BestBlockRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BestBlockRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BestBlockRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BestBlockRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BestBlockRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BestBlockRequest}
 */
proto.walletrpc.BestBlockRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BestBlockRequest;
  return proto.walletrpc.BestBlockRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BestBlockRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BestBlockRequest}
 */
proto.walletrpc.BestBlockRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BestBlockRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BestBlockRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BestBlockRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BestBlockRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BestBlockRequest} The clone.
 */
proto.walletrpc.BestBlockRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BestBlockRequest} */ (jspb.Message.cloneMessage(this));
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BestBlockResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BestBlockResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BestBlockResponse.displayName = 'proto.walletrpc.BestBlockResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BestBlockResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BestBlockResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BestBlockResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BestBlockResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    height: msg.getHeight(),
    hash: msg.getHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BestBlockResponse}
 */
proto.walletrpc.BestBlockResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BestBlockResponse;
  return proto.walletrpc.BestBlockResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BestBlockResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BestBlockResponse}
 */
proto.walletrpc.BestBlockResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setHeight(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BestBlockResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BestBlockResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BestBlockResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BestBlockResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHeight();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.BestBlockResponse} The clone.
 */
proto.walletrpc.BestBlockResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.BestBlockResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional uint32 height = 1;
 * @return {number}
 */
proto.walletrpc.BestBlockResponse.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 1, 0));
};


/** @param {number} value  */
proto.walletrpc.BestBlockResponse.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BestBlockResponse.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/**
 * optional bytes hash = 2;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.BestBlockResponse.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BestBlockResponse.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.BestBlockResponse.prototype.setHash = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SweepAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SweepAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SweepAccountRequest.displayName = 'proto.walletrpc.SweepAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SweepAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SweepAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SweepAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SweepAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    sourceAccount: msg.getSourceAccount(),
    destinationAddress: msg.getDestinationAddress(),
    requiredConfirmations: msg.getRequiredConfirmations(),
    feePerKb: msg.getFeePerKb()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SweepAccountRequest}
 */
proto.walletrpc.SweepAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SweepAccountRequest;
  return proto.walletrpc.SweepAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SweepAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SweepAccountRequest}
 */
proto.walletrpc.SweepAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourceAccount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDestinationAddress(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequiredConfirmations(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setFeePerKb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SweepAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SweepAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SweepAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SweepAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSourceAccount();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getDestinationAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getFeePerKb();
  if (f !== 0.0) {
    writer.writeDouble(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SweepAccountRequest} The clone.
 */
proto.walletrpc.SweepAccountRequest.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SweepAccountRequest} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional string source_account = 1;
 * @return {string}
 */
proto.walletrpc.SweepAccountRequest.prototype.getSourceAccount = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/** @param {string} value  */
proto.walletrpc.SweepAccountRequest.prototype.setSourceAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string destination_address = 2;
 * @return {string}
 */
proto.walletrpc.SweepAccountRequest.prototype.getDestinationAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldProto3(this, 2, ""));
};


/** @param {string} value  */
proto.walletrpc.SweepAccountRequest.prototype.setDestinationAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 required_confirmations = 3;
 * @return {number}
 */
proto.walletrpc.SweepAccountRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.SweepAccountRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional double fee_per_kb = 4;
 * @return {number}
 */
proto.walletrpc.SweepAccountRequest.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.SweepAccountRequest.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SweepAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SweepAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SweepAccountResponse.displayName = 'proto.walletrpc.SweepAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SweepAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SweepAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SweepAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SweepAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    unsignedTransaction: msg.getUnsignedTransaction_asB64(),
    totalPreviousOutputAmount: msg.getTotalPreviousOutputAmount(),
    totalOutputAmount: msg.getTotalOutputAmount(),
    estimatedSignedSize: msg.getEstimatedSignedSize()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SweepAccountResponse}
 */
proto.walletrpc.SweepAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SweepAccountResponse;
  return proto.walletrpc.SweepAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SweepAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SweepAccountResponse}
 */
proto.walletrpc.SweepAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUnsignedTransaction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalPreviousOutputAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalOutputAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEstimatedSignedSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SweepAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SweepAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SweepAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SweepAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getUnsignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTotalPreviousOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getTotalOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getEstimatedSignedSize();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * Creates a deep clone of this proto. No data is shared with the original.
 * @return {!proto.walletrpc.SweepAccountResponse} The clone.
 */
proto.walletrpc.SweepAccountResponse.prototype.cloneMessage = function() {
  return /** @type {!proto.walletrpc.SweepAccountResponse} */ (jspb.Message.cloneMessage(this));
};


/**
 * optional bytes unsigned_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SweepAccountResponse.prototype.getUnsignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldProto3(this, 1, ""));
};


/**
 * optional bytes unsigned_transaction = 1;
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {string}
 */
proto.walletrpc.SweepAccountResponse.prototype.getUnsignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUnsignedTransaction()));
};


/**
 * optional bytes unsigned_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SweepAccountResponse.prototype.getUnsignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUnsignedTransaction()));
};


/** @param {!(string|Uint8Array)} value  */
proto.walletrpc.SweepAccountResponse.prototype.setUnsignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_previous_output_amount = 2;
 * @return {number}
 */
proto.walletrpc.SweepAccountResponse.prototype.getTotalPreviousOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 2, 0));
};


/** @param {number} value  */
proto.walletrpc.SweepAccountResponse.prototype.setTotalPreviousOutputAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_output_amount = 3;
 * @return {number}
 */
proto.walletrpc.SweepAccountResponse.prototype.getTotalOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 3, 0));
};


/** @param {number} value  */
proto.walletrpc.SweepAccountResponse.prototype.setTotalOutputAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 estimated_signed_size = 4;
 * @return {number}
 */
proto.walletrpc.SweepAccountResponse.prototype.getEstimatedSignedSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldProto3(this, 4, 0));
};


/** @param {number} value  */
proto.walletrpc.SweepAccountResponse.prototype.setEstimatedSignedSize = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.SyncNotificationType = {
  SYNCED: 0,
  UNSYNCED: 1,
  PEER_CONNECTED: 2,
  PEER_DISCONNECTED: 3,
  FETCHED_MISSING_CFILTERS_STARTED: 4,
  FETCHED_MISSING_CFILTERS_PROGRESS: 5,
  FETCHED_MISSING_CFILTERS_FINISHED: 6,
  FETCHED_HEADERS_STARTED: 7,
  FETCHED_HEADERS_PROGRESS: 8,
  FETCHED_HEADERS_FINISHED: 9,
  DISCOVER_ADDRESSES_STARTED: 10,
  DISCOVER_ADDRESSES_FINISHED: 11,
  RESCAN_STARTED: 12,
  RESCAN_PROGRESS: 13,
  RESCAN_FINISHED: 14
};

goog.object.extend(exports, proto.walletrpc);
